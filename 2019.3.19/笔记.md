### md秘钥 ###
邮箱： Soar360@live.com
秘钥：
 GBPduHjWfJU1mZqcPM3BikjYKF6xKhlKIys3i1MU2eJHqWGImDHzWdD6xhMNLGVpbP2M5SN6bnxn2kSE8qHqNY5QaaRxmO3YSMHxlv2EYpjdwLcPwfeTG7kUdnhKE0vVy4RidP6Y2wZ0q74f47fzsZo45JE2hfQBFi2O9Jldjp1mW8HUpTtLA2a5/sQytXJUQl/QKO0jUQY4pa5CCx20sV1ClOTZtAGngSOJtIOFXK599sBr5aIEFyH0K7H4BoNMiiDMnxt1rD8Vb/ikJdhGMMQr0R4B+L3nWU97eaVPTRKfWGDE8/eAgKzpGwrQQoDh+nzX1xoVQ8NAuH+s4UcSeQ==

## emmet-插件 ##
- Ctrl+D 选中光标所占的文本，继续操作则会选中下一个相同的文本。入图中的div
- Ctrl+Enter 在下一行插入新行, Ctrl+Shift+Enter 在上一行插入新行。
- Ctrl+Shift+↑ 将光标所在行和上一行代码互换
- Ctrl+Shift+D 复制光标所在整行，插入到下一行。
- Tab 向右缩进。Shift+Tab 向左缩进。
- Ctrl+Shift+K 删除整行。或者ctrl+x,但注意这是剪切，ctrl+v还是会粘贴回来
- Ctrl+/ 注释单行。Ctrl+Shift+/ 注释多行。重复操作取消注释
### git基本命令
+ 在文件夹内 输入 git init  初始化仓库
+ git status 查看文件是否被暂存或存储 ,不是必须的命令
+ git add . 把文件存入暂存区
+ git commit -m'xxxx'  把文件存入到存储区  -m'xxx'不能忘

+ 添加远程源将本地仓库和远程仓库建立连接
```
	//nevermo2013/noteH5.git 每个人不同 看个人设置
	git remote add origin https://github.com/nevermo2013/noteH5.git
```
+ git push -u origin master  把本地文件提到到远程github
+ 第二次暂存 提交  后 不需要再配置源信息,提交只需要Git push即可


##常用浏览器及其内核
+ Trident(IE内核) 
+ Gecko （Firefox）
+ Webkit（Safari） 
+ Presto（Opera） 
+ Blink（Chrome） 

## html的结构
+ 结构 html、表现 css、行为 javascript

## 常用字符
+ `h1~h6` 共六级标签 h1标签在一个版面中最多只能有一个
+ `<br>` 换行符 开发不常用
+ `<sup>和<sub>`  上标和下标
- `&nbsp; &lt; &gt;` 转义字符 

### a标签可以作为锚点 
- 实现锚点跳转的方式有两种
+ 一种是`<a>`标签的name属性
	
```  
	<a href="#1">发展历程</a>
	<a name="1"></a>
```

+ 一种是`<a>`标签的id属性
	
`
	<a href="#1">发展历程</a>
	<a id="1"></a>
`
	
###form表单

```

<head>
	<meta charset="UTF-8">
	<title>Document</title>
	<style>
		*{
			margin: 0;
			padding: 0;
		}
	</style>
</head>
<body>
	<!-- action 提交的地址 
		后台程序员给的  /abc  /xxx	
	-->
	<!-- 目前 只要有表单 就必须有form -->
	<form action="http://www.baidu.com" method="get">
		<!-- 用户名
		密码      type = text 单行文本
		性别 单选
		爱好 多选
		经验 下拉框
		头像  file
		个人介绍  多行文本
		提交 -->
		<!-- 每一个表单控件 都有一个name属性
							都有value属性(可以设置默认值)
								readonly 只读属性
								disabled 不可用(不常用)
							checked  单选/多选默认选中
							selected  下拉框默认选中
							 -->
		<!-- /abc?sex=on&like=on&exp=1~3&avatar=&bak=阿斯蒂芬
			get 方式提交,参数在地址栏显示,不安全.数据量有上限
			 数据提交的一种格式,参数的格式 ?key=v1&key2=v2&key3=v3...
			post 提交,参数在请求体保存,相对安全,数据量没有上限

		 -->
		用户名: <input type="text" name="username" value="李四"  readonly> <br>
		密码: <input type="password" name="password"> <br>
		性别:  男:<input  type="radio" name="sex" value="0">
			   女:<input checked type="radio" name="sex" value="1"><br>
			   <!-- value="001" 在处理这种数据的时候,后台一般会有数据词典 -->
		爱好:  
			<!-- label 可以把内容和标签包括起来 -->
			<label>
				篮球 <input checked type="checkbox" name="like" value="001">  
			</label>
			
				足球 <input type="checkbox" name="like" value="002">
				乒乓球 <input checked type="checkbox" name="like" value="003"><br>
		经验:  
			<select name="exp">
				<option value="100">无</option>
				<option value="101" selected>1~3</option>
				<option value="102">3~5</option>
			</select><br>
		头像:  <input type="file" name="avatar"><br>
		个人介绍:  
		<textarea name="bak" cols="30" rows="5"></textarea><br>
		<input type="submit" value="提交">
	</form>
	<a href="http://www.baidu.com" >当前页面刷新</a>
	<a href="http://www.baidu.com" target="_parent">父类窗口刷新</a>
	<a href="http://www.baidu.com" target="_top">顶级父类窗口刷新</a>
</body>
</html>
```
## iframe 画中画 ##
```
	<iframe src="http://player.bilibili.com/player.html?	aid=31008479&cid=54146608&page=1" scrolling="no" border="0" 	frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>
	<iframe src="http://www.baidu.com" frameborder="0" scrolling="auto"></iframe>
```
###css的书写位置分为3种 css样式
+ 行内样式表 `<p style="color:blue;font-size: 30px;">我是一个p标签</p>`
+ 内嵌样式表 `<style> </style>`
+ 外部(链接)样式表 	`<link rel="stylesheet" href="style.css">`
+ 导入样式表     ` <style>  @import "style.css"; </style>`

##css样式层叠性和继承性 与css样式选择
> 如果出现了样式冲突 必然只能有一个样式生效
- 1. 如果写了相同选择器,希望某个选择器权重最高,只需额外添加class即可 谁权重高谁生效
- 2. 如果两个选择器是一样的 那么采用就近原则  权重一样 就近原则
+ 继承性 
- 几乎所有的字体属性都能被继承
特殊:

1.   a标签的颜色不能实现继承;
2.   h标签的大小不能实现继承;

## 常见选择器
+ 标签选择器  p
+ class选择器  .p1
+ id选择器   #p1
+ 交集选择器   .p1.danger
+ 并集选择器  .p1,.p2,.p3...
+ 后代选择器  .box .innerbox
+ 通用选择器  * 

## 简单选择器的优先级
+ 行内样式>id选择器>class选择器>标签选择器>通用选择器

## 复杂选择器优先级
+ 技巧: 
- 1. 如果写了相同选择器,希望某个选择器权重最高,只需额外添加class即可
- 2. 如果两个选择器是一样的 那么采用就近原则

+ 比较权重  权重可以叠加 
- 行内        1000
- id          100
- class       10 (一般选择器控制在3个以内)
- 标签        1
- 通用/继承   0 

+ 颜色
	- 预定义颜色： blue  yellow  pink  purple  red  等
	- 十六进制： 每两位表示一种颜色的深度  分别表示 red  green  blue; 比如： #ff00ff
	- rgb:   rgb(0,0,255) ==> 绿色 ； rgb和十六进制是可以互换的。
	- rgba:  rgba(0,0,255,0.5) ==> 跟rgb一样，a是透明度：0~1； 0.5==> .5

#常用属性
- | width / height  | 宽高(块状单位有效) | px 百分比 em等 |
- | text-align | 文字对齐方式 | center left right  
- | text-index | 首行缩进 | px  em等 |
- | cololr | 字体颜色 | color |
+ opacity透明度0-1
##font 缩写形式
+ font|字体缩写|font:italic     (font-style | 字体样式 | Italic 斜体 / normal 正常)
+                   bolder     (font-weight | 字体加粗 | 100-900.加粗700-900/ bolder lighter normal)
+                   20px/1.2   (font-size | 字体大小 | px  em等 
                                line-height | 行高 | 单位px/倍数 /百分比;-设置文字的行间距-单行文字垂直居中,行高=父类盒子高度) 
+                   'Arial','Microsoft YaHei'    (font-family | 字体 | 微软雅黑	Microsoft YaHei、黑体 SimHei、Arial等)

##background 缩写形式
+ background  | 简写（顺序不能错） | 
+ background: green          (background-color  | 背景图片颜色 | color )
+            url(1.jpg)     (background-image  | 背景图片 | url("1.png");)
+            no-repeat      (background-repeat  | 平铺方式 | repeat 、 no-repeat  、 repeat-x 、 repeat-y)
+ 			 center center  (background-position  | 图片位置 |20px 30px left、 right、 top、 bottom、 center 相对于父类盒子水平垂直高度百分比50%60%)
+			 fixed; 	    (background-attachment  | 背景滚动 | scroll默认滚动、(fixed 注意：基于body的定位))

### 标签的表现形式
+ 块状标签  独占一行，宽高有效。 比如： div   p  h1~h6  form  table   hr  br  ul>li   ol>li dl>dt/dd 
+ 行内块标签  可以同一行显示，宽高有效。  比如: input select  img   button 
+ 行内标签  可以同一行显示，但是宽高无效， margin-top/margin-bottom 无效。。  比如： a   span   strong  del ins  em  i  b  等字体标签

### 盒子模型
> CSS处理网页时，它认为每个元素都包含在一个不可见的盒子里。包含内容区域、 padding（内边距） 、 border（边框）、margin（盒子与盒子的距离）

+ padding
	- padding:10px 20px 30px 40px 这样会设置元素的上、右、下、左四个方向的内边距。
	- padding:10px 20px 30px; 分别指定上、左右、下四个方向的内边距
	- padding:10px 20px; 分别指定上下、左右四个方向的内边距
	- padding:10px;同时指定上左右下四个方向的内边距
	- 同时在css中还提供了padding-top、padding-left、padding-right、padding-bottom分别用来指定四个方向的内边距。
+ margin
	- 用法和padding类似，同样也提供了四个方向的margin-top/right/bottom/left。
	- margin: xxx auto;可以使元素居中。
	- 嵌套崩塌：两个盒子发生嵌套的时候，给子类设置maring会给父类造成一种崩塌现象，子类的margin-top没有效果，而直接作用到父类。
	- 解决方案：  1. 父类  overflow: hidden ; 2. 父类 设置极小的padding
	- 重叠： 如果垂直两个块状元素同时设置了margin-bottom和margin-top,那么这两个值将会发生重叠,不会累加，哪个值大用哪个。
	- margin-top/margin-bottom 对于行内元素无效。
+ margin
	- 用法和padding类似，同样也提供了四个方向的margin-top/right/bottom/left。
	- margin: xxx auto;可以使元素居中。
	- 嵌套崩塌：两个盒子发生嵌套的时候，给子类设置maring会给父类造成一种崩塌现象，子类的margin-top没有效果，而直接作用到父类。
	- 解决方案：  1. 父类  overflow: hidden ; 2. 父类 设置极小的padding
	- 重叠： 如果垂直两个块状元素同时设置了margin-bottom和margin-top,那么这两个值将会发生重叠,不会累加，哪个值大用哪个。
	- margin-top/margin-bottom 对于行内元素无效。
	
+ border
	- 可以在元素周围创建边框，边框是元素可见框的最外部。
	- border:1px solid red 分别指定了边框的宽度、颜色和样式,是一种缩写： border-widht:  border-style border-color
	- border-style: none (默认)  /  dashed(虚线) / dotted（点）  / solid(实线)  /  double(双实线)
	- 可以单独设置某一条边框： border-right: 20px solid blue;
	
## 水平垂直居中 ##
> .father { height:200px; position:relative;}
> .son { position:absolute; top:0; right:0; bottom:0; top:0; margin:auto;}
> 利用position拉伸效果  和强行设置宽高会让多余的空间被剩余 margin 自动分配剩余空间的特性 IE8+
## js的组成 ##


- ECMAscript js标准 js基础语法
- dom 通过js操作网页元素 网页中的任意标签被称为dom元素
- bom 通过api操作浏览器
- 

## 用js输出内容 ##

- alert() 在页面弹出一个对话框,早期js调试用
- confirm() 在页面弹出一个对话框.常配合if判断使用. 
```
	if(confirm("你是中国人吗?")){
		alert("您好")
	}else{
		alert("对不起我不会英语")
	}
```

- prompt() 弹出对话框,用于接收用户输入信息
- console.log() 将信息显示在控制台,用于js调试
- docunment.write() 在页面输出消息 几乎用不到
- docunment.write不仅能输出信息还能输出标签
- 转义字符 \ ,  \”   转双引  , \’转单引  ,  \n转换行  ,  \r 转回车

## js命名规范 ##

- 可以用英文_$开头
- 不能用特殊符号或者特殊符号开头
- 不能用数字开头
- 不推荐使用中文命名
- 不推荐使用关键字和保留字命名
- js中严格区分大小写

## js关键字 ##

> break	do	instanceof	typeof
case	else	new	var
catch	finally	return	void
continue	for	switch	while
debugger*	function	this	with
default	if	throw	delete
in	try	 	abstract	enum	int	short
boolean	export	interface	static
byte	extends	long	super
char	final	native	synchronized
class	float	package	throws
const	goto	private	transient
debugger	implements	protected	volatile
double	import	public	 

## js数据类型 ##

### 简单数据类型 ###


- Number 数字类型 包括正数负数小数
- 字符串 String凡是用单引号或者双引号 引起的都是字符串.
- 布尔数据类型 Boolean 只有两个值 true和false 实际运算中true=1 , false=0 
- underfined 
- 变量未初始化 定义了变量,没有给变量赋值
- null 变量未引用 值为空 object

### 复杂数据类型 ###

- object 对象  对象的属性可以是函数, 
- 我们称这个函数为对象的方法,  调用函数我们就说调用对象的方法;
### 调用对象的两种方法 ###
`	
	var person = {
    firstName:"John",
    lastName:"Doe",
    [1]:50,
    "!":"blue"
	};

	person.lastName;
	非正常命名用person[1] 中括号, 需要字符串的命名要用字符串加中括号调用   person["!"]
`



- array 数字
- 使用 typeof 可以判断数据类型

## 数据类型转换 ##
### 显性转换 强制类型转换
> 将其他的数据类型转换为String  
> 方式一
- 调用被转换数据类型的toString()方法    a = a.toString(); 
- toString方法不会影响到原变量,他会将转换的结果返回;
- 但是注意:null和undefined这两个值没有toString方法,如果调用他们的方法会报错
> 方式二
- 调用String()函数,并将被转换的数据作为参数传递给函数; a = String(a);
- 使用String()函数做强制类型转换时,对于Number和Boolean实际上就是调用的toString()方法;
- 但是对于null和undefined,就不会调用toString方法,直接将null变成"null" undefined变成"undefined";
> 将其他的数据类型转换为Number
>使用Number函数

- 纯数字字符串,直接转换为数字, a = Number("1234"); 1234
- 字符串有非数字内容转换为NaN, a = Number("12a");   NaN
- 字符串是空串或者全是空格的字符串转换为0, a = Number("")/Number("  ");  0 
- 布尔值转数字 ture 1 false 0
- Null 转换为 0;                 null表示"没有对象"，即该处不应该有值
- undefined 转换为 NaN 			undefined表示"缺少值"，就是此处应该有一个值，但是还没有定义
> 使用parseInt 和 parseFloat 专门对付字符串 如果传入非字符串会转换为字符串再解析
> parseInt(null)  NaN
> 从左往右查找数字,parseInt("123.23px")   123;
> parseInt(13,14) 17; 以14进制解析13;     45       2~36进制都可以用;
> a = 17;   a.toString(13) 以13进制解析17  14; 

> 转换为Boolean值
> 使用Boolean函数;
> 0,NaN,""空串,null,undefined,false 为假
### 进制转换 ###
> a = "070"  parseInt(a,10);



## 隐形类型转换
> 任何类型和字符串相加都会转换为字符串 可以拼串; 内部调用String()
> (值) + ""  "(值)"  (1 + 1)  (2)   (true) (true)  前面的为括号运算  
> 算数运算符,对非Number类型的值进行运算时,会将这些值转换为Number类型,任何值和NaN做运算都是NaN;
> !!为任意数据类型做两次非运算,即可将其转换为boolean值  同Boolean()   !!可以用来判断是否为NaN

> 与或先将其转换为布尔值运算,之后返回原值; 与都为真才是真 有一个真就是真; 
> a++ 返回原值 ++a返回新值; 

## 比较运算符 ##
> > <  >= <=    数字或者有一个为数字比较前转换为Number类型比较  
> 比较两个字符串数字一定要转型   + "20"  >  + "19" 
> 都是字符串比较会比较unicode编码 只比较第一位  一位一位比较的  
> 有布尔值也会转换为Number进行比较   
> null == 0  为false;  
## 相等运算符 ##
#相等运算符转换规则和比较运算符不同 #
> 会把null当做对象看,null == undefined  null == null;
> undefined 衍生自null 所以判断== 会返回true
> NaN 不等于任何值,包括他自己;


> == != === !==
## js算数运算符 ##
>    运算符不会改变值  需要赋值获取换回结果

### unicode编码使用 ###
> 编码为16进制   js里面"\u2620" " 网页里&#编码;  "  这里的编码需要十进制;
-  +加号 
> 2 =  1 + 1  
>   
> 11  = 1 + "1"
> 
> woai1 = "woai" + 1

> 11woai = 1 + 10 + "woai"

> woai110  = "woai" + 11 + 0

- -减号
> 9 = 10 - 1
> 
> NaN = 10 - "您好"
> 
> NaN = "我好" - "你好"
> 
> NaN not a number

- /除号
> 1 = 1 / 1
> 
> 2 = 4 / "2"
> 
> NaN = "您好" / 2
> 
> Infinity = 1 / 0
> 
> -Infinity = -1 / 0
> 
> 有括号的先算括号里面的()


算数运算符,对非Number类型的值进行运算时,会将这些值转换为Number类型,任何值和NaN做运算都是NaN;

## 自增自减 ##

>如果变量没有直接参与运行中，i++  和  ++i表示的含义是：在变量原来值的基础上加1。
>
i++   i先参与运算，再执行++

> ++i   ++执行，i再参与运算 

## 运算符优先级 ##
- .   []   new
- ()
- ++   --
- !  ~  +单目  -单目  typeof void  delete
- %  *   /
-   双目+  双目-  
-   <<  >>  >>>
-   <  <=  >  >=
-   ==  !==  ===
-   &   ^    |
-   &&
-   ||
-     ?:
-     = +=  -=  *=  /=  %=  <<=   >>=  >>>=   &=   ^=   |=
-     ,
-     
-   不用记分不清的时候直接用()就可以的 

## Date 和 Math 对象使用 ##

### Date的用法 ###

> Date() 返回当前时间日期
> 
> getDate() 返回一个月的某一天
> 
> getMonth() 返回月份 以数字形式存储 返回0~11

> getFullYear() 返回年
>
> getHours() 返回小时部分
>
>getMinutes() 返回分钟部分
>
>getSeconds()返回秒数
>
>getDay() 从 Date 对象返回月份 (0 ~ 11)。
> 

### Math对象 ###
> Math.ceil() 天花板函数 对数字进行向上舍入 Math.ceil(2.3) 3
> 
> Math.floor() 地板函数 
> 
> Math.max(x,y) 返回最大值
> 
> Math.min(x,y) 返回最小值
> 
> Math.random()伪随机 返回[0,1)直接的数值
> 
> 任意随机数
> 1~100
> 
> Math.floor(Math.random()*数量+min) 
> 
> 即Math.floor(Math.random()*100+1) 
> 
> Math.pow(x,y) 返回X值的y次方
> 
> Math.round(x) 	把数四舍五入为最接近的整数。
> 
>  本身会有错误2.49999999999999999999 >==== 3 
> 

## 逻辑运算符 ##
- 先将其转换为布尔值运算,之后返回原值;
-  && || !
-  参与逻辑运算的都是布尔值.true和false 
-  &&都真才真 遇到false就返回 没有遇到就返回最后一个值(表达式的值)
-  || 只要有一个为真就是真 遇到true就返回,没有遇到就返回最后一个值(表达式的值)
-  转化为布尔值false的有 : underfined null NaN "" 0 false
-  !!强制将其他类型值转换为布尔类型值
## js基本语法规则 ##
- 语句后面要用分号结束;
- js语法错误会引发后续代码终止,但不会影响其他js代码块;
- 书写格式要规范,= + / - 两边都应该有空格;


## js语句 ##
>  {
> 		
> }
>  大括号表示代码块  把这些代码看出一个整体,要执行都执行,要不执行都不执行;
>  if(条件表达式true){
>
>   条件为真的时候做的事情
>   
> }else if{
>
>   条件为假的时候做的事情
>   
> }else{
> }
> 该语句只有一个代码块被执行,一旦代码块执行,立刻结束
>
> 三元运算符
>
> a>3 ? alert("大于3") : alert("小于3")

>Switch语句后的变量必须和case后面的数据类型保持一致,适合比较少的种类判断;
>Switch语句判断条件为全等;
>switch(变量n){
>
>     case 10:
>            执行的代码;
>            break;
>     case 20:
>            执行的代码;
>            break;
>     default:
>            执行的代码;
>            break;     
>
>While循环
>
>while(条件表达式){
>
>             当条件表达式结果为true,会一直执行while循环体内的代码。
>             
>             当条件表达式的结果为false，while循环不再执行。
>             
>             }  

>for循环
>      
>      for(var i = 0; i <= 1; i ++){
>          循环体代码
>      }       
>               
>执行顺序: 
- 首先进行变量初始化,并进行条件判断
- 如果条件结果为true,那么执行循环体内的代码,然后执行 i++;
- 判断条件是否为true,继续执行循环体内的代码,否则跳出循环
>
>Break 语句
>
>在循环体内 代码遇到break,代码立马结束当前循环,当前循环指的是break所在的循环体
>
>Continue 语句
>
>Continue语句指的是跳出本次循环,该语句后面的代码不被执行

#parseInt 

> parseInt(demo, 基底进制) 砍断特点 "100px"输出100 123.abc 输出123
				101010 2 以目标进制为基底转换为10进制
> string(demo)

> demo.toString() undifined null不能用

> demo.toSting(8) 把10进制转换成8进制; 以10进制转换为目标进制;
> 
把2进制转换成16进制

````

<script>
  var num 10101010;
  var test parseInt(num,2);
  console.log(test.toString(16));
</script>

```

## 预编译 ##
-   在全局作用域中 变量声明是给Windows对象创建了一个属性  函数声明是给Windows对象创建了一个方法  
-   变量是Windows的属性,函数是Windows对象的方法;
- 创建AO对象
- 找形参和变量声明.将变量和形参名作为AO属性名,值为undefined
- 将实参值和形参统一
- 在函数体里面找函数声明,值赋予函数体;

## this ##
- this 解析器调用函数时 会向函数传递一个隐含的参数, this指向一个对象(函数执行的上下文对象), 谁调用函数this就指向 谁(调用的对象);
- 当以函数的形式调用时,this是window;
- 当以方法的形式调用时,谁调用方法,this就是谁;
- 当以构造函数的形式调用时,this就是新创建的那个对象;

## Array 数组对象方法 ##
- 改变原数组
> push() 向数组的末尾添加一个或更多元素，并返回新的长度。
> pop() 删除并返回数组的最后一个元素 剪切出来最后一位.
> unshift() 	向数组的开头添加一个或更多元素，并返回新的长度。
> shift() 	删除并返回数组的第一个元素
> reverse() 	颠倒数组中元素的顺序。
> splice() 	删除元素，并向数组添加新元素。 切片 splice(从第几位开始,截取多少长度,在切口处添加新的数据)
> sort() 用于对数组的元素进行排序。arr.sort(function(a,b) {return}) 
- 必须写俩形参;
- 看返回值 
+ 当返回值为负数时,那么前面的数放在前面
+ 为正数时,那么后面的数在前
+ 为0, 不动;
> 
- 不改变原数组
> concat() 连接两个或更多的数组,并返回结果  
> 将一个数组与另一个或多个数组或非数组元素合并 并返回合并后的数组 需要接收
> join() 把数组的所有元素放入一个字符串.元素通过制定的分隔符进行分隔.
> toString() 把数组的所有元素放入一个字符串,元素通过指定的分隔符进行分隔.
> indexOf("lala"[,从第几位开始找默认0]) 方法返回在数组中可以找到一个给定元素的第一个索引,如果不存在,则返回-1;
> lastIndexOf() 倒着搜索;
> slice() 从当前数组中截取一个新的数组，不影响原来的数组，参数 start 从0开
始, end 从1开始 返回一个新的数组，包含从  start 到  end （不包括该元素）的
arrayObject 中的元素。
> array = [];清空数组;

## 字符串的对象方法 ##
> charAt() 获取相应位置字符
> 
> charCodeAt() 方法可返回指定位置的字符的  Unicode 编码。这个返回值是 0 -
65535 之间的整数。

> split() stringObject.split(separator,howmany) 第一个参数分隔符第二个分出来的个数 返回数组,里面是字符串形式.
> 如果把空字符串 ("") 用作 separator，那么 stringObject 中的每个字符之间都会被分割。
> 
> indexOf() 返回字符在字符串中的位置
> lastindexOf()
> 
> concat() 连接字符串
> 
> slice() 方法可提取字符串的某个部分，并以新的字符串返回被提取的部分。
> 
> substr() 用的非常多 substr(起始位置,[取的个数])


> toUpperCase() toLowerCase()	变为大小写 ,不影响原字符串
> 
> substring() 
> 
> String 对象的方法 slice()、substring() 和 substr() （不建议使用）都可返回字符串的指定部分。slice() 比 substring() 要灵活一些，因为它允许使用负数作为参数。slice() 与 substr() 有所不同，因为它用两个字符的位置来指定子串，而 substr() 则用字符位置和长度来指定子串。


## dom 常用操作指令 ##

### dom节点获得 ###
- document.getElementById("demo")
- 最准确的 ， 需要获取的dom元素，必须有id，而且一个页面不能有重复的id
- document.getElementsByTagName("div");
- 效率低  没办法定位元素
- document.getElementsByClassName("a");
- 如果在移动使用，移动端浏览器完全支持。 目前先不考虑<ie8情况，之后学了jQuery或者html5（新的选择器）;

### 节点通过父子属性获得 ###
- parentNode. 获得父亲节点
- nextSibling：调用者是节点
- nextElementSibling：在火狐谷歌IE9都指的是下一个元素节点
- 兼容写法：nextEle =节点.nextElementSibling || 节点.nextSibling 
- previousSibling：调用者是节点
- previousElementSibling：在火狐谷歌IE9都指的是前一个元素节点
- firstChild：调用者是父节点。IE678中指第一个子元素节点（标签）。在火狐谷歌IE9+以后都指的是第一个节点（包括空文档和换行节点）。
- firstElementChild:在火狐谷歌IE9都指的第一个元素节点。
- lastChild:调用者是父节点。IE678中指最后一个子元素节点（标签）。在火狐谷歌IE9+以后都指的是最后一个节点（包括空文档和换行节点）。
- lastElementChild：在火狐谷歌IE9都指的最后一个元素节点。
- childNodes：它是标准属性，嫡出，它返回指定元素的子元素集合，包括HTML节点，所有属性，文本节点   （他还是W3C的亲儿子 ）
火狐 谷歌等高本版会把换行也看做是子节点
- children：非标准属性，庶出，它返回指定元素的子元素集合

## dom节点操作 ##
- 创建节点
- 使用方法是这样的document.createElement();
- 
- 插入节点（使用节点）
- 父节点.appendChild(); var child =  Node.appendChild(child) 方法将一个节点添加到指定父节点的子节点列表末尾。
- var child = node.appendChild(child);
- node 是要插入子节点的父节点.
- child 即是参数又是这个方法的返回值.

- 获取父节点和兄弟节点
- parentNode   方法
- previousSibling
- nextSibling
- 
- 父节点.insertBefore(要插入的节点，参考节点)；
- 如果参考节点为null，那么他将在节点最后插入一个节点。

- 获得父元素子节点
- var node = 父元素.getElementByTagName("li") 方法返回当前节点的指定标签名后代节点
- var node = 父元素.childNodes; 所以的子节点; 
- firstChild 第一个子节点 lastChild 最后一个子节点;
- firstElementChild
- var elment = 父元素.children; 所以的子元素;
- 

- 删除节点   
- 用法：父节点.removeChild（子节点）。节点自己删除自己：
- 不知道父级的情况下，可以这么写：node.parentNode.removeChild(node)

- 复制节点 
- oldNode.cloneNode（true）
- 想要复制的节点调用这个函数cloneNode()，得到一个新节点。 方法内部可以传参，如果是true，深层复制，如果是false，只复制节点本身。

- 节点.属性
- elment.属性名 = 新值 可以修改属性值 className src
- 获取：getAttribute(名称)  当没有属性值的时候返回null 值;有属性值的时候返回字符串"类名"  
-         element.className 当没有属性值返回""空字符串
- 设置：setAttribute(名称, 值)  dom方法 调用属性要用getAttribute;
- 删除：removeAttribute(名称)
- 父元素.firstChild.nodeValue 第一个文本节点的节点值为文本信息;

- 插入元素
- innerHTML(内部的html)可以读可以写      插入可执行的标签，标签和样式会被解析，常用于动态生成页面元素  后面只能加入字符串  
- innerText 插入文本内容，标签和样式会被当做文本内容处理。 没有标签

- document有一个body属性  var body = document.body; 就可以获得body的引用;
- var html = document.documentElement;获得html
- 

## 事件 ##
- 给HTML元素分配事件
- 1 可以使用事件属性,   <button onclick="displayDate()"> Try it </button>
- 2 使用HTML DOM 来分配事件   <script> document.getElementById("my btn").onclick = function(){displayDate()};</script>;
- onclick	鼠标点击某个对象
- onmouseover 支持冒泡;
- onmouseenter 鼠标移到元素上 不支持冒泡
- onmouseout	鼠标从某元素移开  支持冒泡;
- onmouseleave  不支持冒泡
- window.onload = function(){};
- onscroll事件 当元素的滚动条滚动时触发的事件.
- element.onscroll = function(){};  需要注意的是,设置此事件的元素一定要有滚动条.

## 事件对象 `Event`

`Event` 对象代表事件的状态，比如事件在其中发生的元素、键盘按键的状态、鼠标的位置、鼠标按钮的状态

获得event对象兼容性写法 `event || window.event`

`event.target` 事件的目标	获得target兼容型写法  `event.target || event.srcElement`

`e.pageX/Y`		获取鼠标点击的相对于页面的位置
`e.clientX/Y`	获取鼠标点击的相对于可视区域的位置
`e.screenX/Y`	获取鼠标点击的相对于屏幕的位置

`event.type`	事件的类型

`event.button` 鼠标点击的按键(只认识三个键) 可在 `onmousedown` 事件中测试
+ === 0 您点击了鼠标左键
+ === 1 您点击了鼠标中键
+ === 2 您点击了鼠标右键

## 事件监听

`addEventListener` 是 W3C DOM 规范中提供的注册事件监听器的方法。IE < 11 不支持此方法
> 事件监听的方式   addEventListener()		事件去掉 on
> 语法： target.addEventListener(type,listener,useCapture]);
> target： 文档节点、document、window。
> type： 字符串，事件名称，不含“on”，比如 “click”、“mouseover”、“keydown” 等。
> listener：执行函数,匿名函数或者声明函数
> useCapture ：是否使用捕捉，一般用 false。 IE 10 以下不支持捕获型事件
> 作用: 它允许给一个事件注册多个 listener
> 控制触发阶段	(捕获阶段 目标执行阶段 冒泡阶段)
> removeEventListener()

`attachEvent(event,listener)` 也是用来监听事件的，只能用于 IE 10 以下，IE 11 已经废弃此方法

它的优点包括：

1. 它允许给一个事件注册多个 listener。

2. 它提供了一种更精细的手段控制 listener 的触发阶段。（即可以选择捕获或者冒泡）。

3. 事件目标可以是一个文档上的元素 Element,Document和Window或者任何其他支持事件的对象 (比如 XMLHttpRequest)。

> 语法： `target.addEventListener(type,listener,useCapture]);`
> 
> target： 文档节点、document、window 或 XMLHttpRequest。
> 
> type： 字符串，事件名称，不含“on”，比如 “click”、“mouseover”、“keydown” 等。 
> 
> listener：执行
> 。
> 
> useCapture ：是否使用捕捉，一般用 false。  IE 10 以下不支持捕获型事件
>
> 事件三阶段： 捕获阶段，处于目标阶段，冒泡阶段


## `removeEventListener` 移除绑定

1. 如果同一个监听事件分别为“事件捕获”和“事件冒泡”注册了一次，一共两次，这两次事件需要分别移除。两者不会互相干扰。

2. 解绑事件 必须是 外部声明函数;


## 定时器
- 定时调用;
- var timer = setInterval(函数,间隔时间毫秒); 返回值唯一个Number类型的数据;
- 这个数字用来作为定时器的唯一标识  1 
- clearInterval(timer);  可以接受任意值 ,是有效的就停,不是有效的什么也不做; 
- index = index % imgArr[index]   index %= imgArr[index]图片循环  
- 延时调用
- var timer = setTimeout(function(){},300);
- clearTimeout(timer);

## BOM

`ECMAScript` 是 `javascript` 的核心，但是如果要在 `web` 中使用 `javascript`，那么 `BOM` (浏览器对象模型)才是真正的核心。BOM提供了很多对象，用于访问浏览器的功能，这些功能与任何网页内容无关。

`BOM` 的核心对象是 `window` ，它表示浏览器的一个实例。在浏览器中， `window` 对象有双重角色，它既是通过 `javascript` 访问浏览器窗口的一个接口，又是 `ECMAScript` 规定的 `Global` 对象。所有全局作用域中声明的变量、函数都会变成 `window` 对象的属性和方法。

### 三大家族其一 `Offset` 家族


> 家族成员： `offsetWidth` `offsetHeight` `offsetLeft` `offsetTop` `offsetParent`

#### `offsetWidth`  `offsetHeight`  （检测盒子自身宽高）

> 这两个属性，他们绑定在了所有的节点元素上。获取之后，只要调用这两个属性，我们就能够获取元素节点的宽和高。

>` offset宽/高  =  盒子自身的宽/高(width/height) + padding +border`

#### `offsetLeft`  和  `offsetTop`  （检测距离父盒子有定位的左/上面的距离）

> 如果父级都没有定位则以 `body` 为准, `offsetLeft` 从父亲的 `padding` 开始算,父亲的 `border` 不算。
> 在父盒子有定位的情况下，`offsetLeft == style.left`(去掉 px)

#### `offsetTop/Left` 和 `style.top/left` 的区别：

1. 最大区别在于 `offsetTop/Left` 可以返回没有定位盒子的距离左侧的位置。而 `style.top/left` 不可以

2. `offsetTop/Left` 返回的是整数，而 `style.top/left` 返回的是字符串，除了数字外还带有单位：`px`

```js
<div class="d1" style="position:relative;width: 300px;height: 200px;background-color: green;"></div>
<script>
	var d1= document.getElementsByClassName('d1')[0];
	d1.onclick = function(){
		d1.style.width = '400.499999999999999px';
		console.log(d1.offsetWidth);	// 401
		console.log(d1.style.width);	// "400.5px"
		d1.style.top = "50.49999999999999px";
		console.log(d1.style.top)	// "50.5px"
		console.log(d1.offsetTop)	// 51
	}
</script>
```

3. `offsetTop/Left` 只读，而 `style.top/left` 可读写。（只读是获取值，可写是赋值）

4. `obj.style.xxx` 只能获取行内样式

#### `offsetParent`   （检测父系盒子中带有定位的父盒子节点）

> 1、返回改对象的父级 （带有定位）
> 
>&emsp;&ensp;如果当前元素的父级元素没有进行 CSS 定位(absolute,relative,fixed) `offsetParent` 为 `body`
>	
> 2、如果当前元素的父级元素中有 CSS 定位 `offsetParent` 取最近的那个父级元素。

## 缓动动画

> leader = leader + (target - leader) / 10;
> 起点 = 起点 + (终点 - 起点) / 10;


小点的点击事件

```js

for(var i = 0; i < dotts.length; i ++){
	dotts[i].onclick = function(i){
			return function (){
				n = i;
				dotClick(n);
				move(ulEle,n);
			}
	}(i)
}

```


缓动函数
```js

function move(ele,num){
	clearInterval(timer);
	var target = -num * w;
	timer = setInterval(function (){
		var start = ele.offsetLeft;
		if(start === target){
			clearInterval(timer);
			return;
		}
		var step = (target - start) / 10;
		if(Math.abs(step) < 1){
			step = step > 0 ? 1 : -1;
		}
		ele.style.left = start + step + "px";
	},17)
}

```

-----------------------------


## `Scroll` 家族

> 家族成员: `scrollWidth` , `scrollHeight` , `scrollTop` , `scrollLeft`
> scroll方法 , obj.scroll([function(){}]); 可以添加函数  
> scroll事件   
`window.scroll(x,y)`是让window滚动条滚动到那个x,y坐标。//x是水平坐标，y是垂直坐标。

`window.scrollBy(-x,-y)`是让window滚动条相对滚动到某个坐标，- 10即相对向左/向上滚动10像素。

`window.scrollTo(x,y)`和`window.scroll(x,y)`一样。

#### `scrollWidth` 和 `scrollHeight`

> 检测盒子的宽高  内容高度 + padding。（调用者：节点元素。属性。）
> 盒子内容的宽高。（如果有内容超出了，显示内容的高度）

#### `scrollTop` , `scrollLeft`
 
> 被浏览器遮挡的头部和左边部分。
> 可以获取或设置一个元素的内容垂直滚动的像素数。
> ** 浏览器兼容问题： **
> 各浏览器下 scrollTop的差异 
IE6/7/8： 
对于没有 doctype 声明的页面里可以使用  document.body.scrollTop 来获取 scrollTop高度 ； 
对于有 doctype 声明的页面则可以使用 document.documentElement.scrollTop； 
Safari: 
safari 比较特别，有自己获取scrollTop的函数 ： window.pageYOffset ； 
Firefox: 
火狐等等相对标准些的浏览器就省心多了，直接用 document.documentElement.scrollTop ；

兼容写法：
`var scrollTop = document.documentElement.scrollTop || window.pageYOffset || document.body.scrollTop`

## `Client` 家族

> 家族成员 `clientWidth` `clientHeight` `clientTop` `clientLeft`

#### `clientWidth` `clientHeight`

> 检测盒子的宽高 clientHeight/W 盒子 自身宽高 + padding 内容溢出不算
> offsetHeight/W 盒子 自身宽高+ padding + border  
> scrollHeight/W 内容宽高 + padding
> 
> document.documentElement.clientWidth/clientHeight  获取浏览器可视区域的宽高		没有兼容问题
> window.innerWidth/innerHeight		IE <= 8 不支持			表示获取 window 可视区域的内部大小
> window.outerWidth/outerHeight		IE <= 8 不支持			表示整个浏览器窗体的大小



#### `clientTop` `clientLeft`		只读

> 表示内容区域的左上角相对于整个元素左上角的位置实际上就是 border 的宽度
> 内容区域 内容+padding		padding 之外就剩border
> 一个元素顶部和左侧边框(border)的宽度

### offset scroll client 图片详解 ###
![](https://i.imgur.com/Zy1OBNS.png)
![](https://i.imgur.com/Fi3qsGR.png)
![](https://i.imgur.com/j7pEmfV.png)
https://blog.csdn.net/k491022087/article/details/52629743

## 获取元素的样式

> 内嵌样式	  行内样式  	可以通过 `ele.style.styleName` 获取
> 
> 内联样式和外联样式可以通过以下两种方式获取

1. `window.getComputedStyle(element, [pseudoElt]).styleName`		返回的是一个字符串,`window`可省略
	+ 仅用于谷歌和火狐等标准浏览器
	+ `element` 用于获取计算样式的元素。
	+ `pseudoElt` 指定一个要匹配的伪元素的字符串。必须对普通元素省略（或`null`）,一般都写成 `null`.  如果要获取伪元素的样式,则写上要获取的伪类的名字,例如:
	+ ```html
	
		<style>
			h3::after {
        content: "hello world!";
			}
		</style>
		<h3>带有伪元素</h3>
		<script>
			var h3 = document.getElementsByTagName('h3'), 
			result = getComputedStyle(h3, '::after').content;
			console.log(result); 		// "hello world!"
		</script>
		
	```
2. `element.currentStyle.styleName` 仅用于 IE 

3. 兼容写法:

```js

/**
* 获取任意元素的css样式
**/
function getStyle(ele,styleName){
	if(ele.currentStyle){
		return ele.currentStyle[styleName];
	}else{
		return window.getComputedStyle(ele,null)[styleName];
	}
}

```

**取对象的属性  如果该属性是变量,那么需要用[]的形式获取**

```js

var abc = "name";
var user = {
	name:'张三',
	age:20
}
console.log(user[abc]);

```

## 事件委托

> 通过监听一个父元素，来给不同的子元素绑定事件，减少监听次数，从而提升速度。
> 由于事件的冒泡机制,可以使用事件委托的方式给元素添加事件,多用于ul监听事件更改li的情景

```
 lis[0].parentNode.onclick = function (e){
 e = e || window.event;
 var t = e.target;			// e.target  事件的目标  在IE下有兼容问题  e.srcElement
 var t = e.target || e.srcElement;
 console.log(t);
 元素的 元素.tagName 的返回值都是大写
 if(t.tagName === "LI"){
 t.style.color = "red";
}
}
```
## 阻止冒泡

> `event.st
> opPropagation();`		存在兼容问题	(面试题)
> IE <= 10 专用 `event.cancelBubble = true`
> 兼容写法 
> `event.stopPropagation?event.stopPropagation():event.cancelBubble = true;`



















