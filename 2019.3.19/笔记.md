### md秘钥 ###
邮箱： Soar360@live.com
秘钥：
 GBPduHjWfJU1mZqcPM3BikjYKF6xKhlKIys3i1MU2eJHqWGImDHzWdD6xhMNLGVpbP2M5SN6bnxn2kSE8qHqNY5QaaRxmO3YSMHxlv2EYpjdwLcPwfeTG7kUdnhKE0vVy4RidP6Y2wZ0q74f47fzsZo45JE2hfQBFi2O9Jldjp1mW8HUpTtLA2a5/sQytXJUQl/QKO0jUQY4pa5CCx20sV1ClOTZtAGngSOJtIOFXK599sBr5aIEFyH0K7H4BoNMiiDMnxt1rD8Vb/ikJdhGMMQr0R4B+L3nWU97eaVPTRKfWGDE8/eAgKzpGwrQQoDh+nzX1xoVQ8NAuH+s4UcSeQ==
## 常用网站 ##
- <a href="http://www.bootcss.com/">bootstrap</a>
- <a href="https://www.swiper.com.cn/">swiper</a>
- npm
- lightbox 灯箱;
- echar
- layui
- jqcolor
- three.js
- font-awesome
- icon-font
- animate.css  https://daneden.github.io/animate.css/
- www.zhaozi.cn
- www.youziku.com
- fullpage.js
- wow.js
- cubic
- layui

## emmet-插件 ##
- Ctrl+D 选中光标所占的文本，继续操作则会选中下一个相同的文本。入图中的div
- Ctrl+Enter 在下一行插入新行, Ctrl+Shift+Enter 在上一行插入新行。
- Ctrl+Shift+↑ 将光标所在行和上一行代码互换
- Ctrl+Shift+D 复制光标所在整行，插入到下一行。
- Tab 向右缩进。Shift+Tab 向左缩进。
- Ctrl+Shift+K 删除整行。或者ctrl+x,但注意这是剪切，ctrl+v还是会粘贴回来
- Ctrl+/ 注释单行。Ctrl+Shift+/ 注释多行。重复操作取消注释
### git基本命令
+ 在文件夹内 输入 git init  初始化仓库
+ git status 查看文件是否被暂存或存储 ,不是必须的命令
+ git add . 把文件存入暂存区
+ git commit -m'xxxx'  把文件存入到存储区  -m'xxx'不能忘

+ 添加远程源将本地仓库和远程仓库建立连接
```
	//nevermo2013/noteH5.git 每个人不同 看个人设置
	git remote add origin https://github.com/nevermo2013/noteH5.git
```
+ git push -u origin master  把本地文件提到到远程github
+ 第二次暂存 提交  后 不需要再配置源信息,提交只需要Git push即可


##常用浏览器及其内核
+ Trident(IE内核) 
+ Gecko （Firefox）
+ Webkit（Safari） 
+ Presto（Opera） 
+ Blink（Chrome） 

## vertical-align ##
- 父盒子的基线是由行内框里行高最高的元素决定的;   行高最高的元素的字体大小会决定基线的高度;
- 父盒子的其他线是由父盒子的字体大小决定的;
## html的结构
+ 结构 html、表现 css、行为 javascript

## 常用字符
+ `h1~h6` 共六级标签 h1标签在一个版面中最多只能有一个
+ `<br>` 换行符 开发不常用
+ `<sup>和<sub>`  上标和下标
- `&nbsp; &lt; &gt;` 转义字符 

### a标签可以作为锚点 
- 实现锚点跳转的方式有两种
+ 一种是`<a>`标签的name属性
	
```  
	<a href="#1">发展历程</a>
	<a name="1"></a>
```

+ 一种是`<a>`标签的id属性
	
`
	<a href="#1">发展历程</a>
	<a id="1"></a>
`
	
###form表单

```

<head>
	<meta charset="UTF-8">
	<title>Document</title>
	<style>
		*{
			margin: 0;
			padding: 0;
		}
	</style>
</head>
<body>
	<!-- action 提交的地址 
		后台程序员给的  /abc  /xxx	
	-->
	<!-- 目前 只要有表单 就必须有form -->
	<form action="http://www.baidu.com" method="get">
		<!-- 用户名
		密码      type = text 单行文本
		性别 单选
		爱好 多选
		经验 下拉框
		头像  file
		个人介绍  多行文本
		提交 -->
		<!-- 每一个表单控件 都有一个name属性
							都有value属性(可以设置默认值)
								readonly 只读属性
								disabled 不可用(不常用)
								placeholder 默认字;
							checked  单选/多选默认选中
							selected  下拉框默认选中
							 -->
		<!-- /abc?sex=on&like=on&exp=1~3&avatar=&bak=阿斯蒂芬
			get 方式提交,参数在地址栏显示,不安全.数据量有上限
			 数据提交的一种格式,参数的格式 ?key=v1&key2=v2&key3=v3...
			post 提交,参数在请求体保存,相对安全,数据量没有上限

		 -->
		用户名: <input type="text" name="username" value="李四"  readonly> <br>
		密码: <input type="password" name="password"> <br>
		性别:  男:<input  type="radio" name="sex" value="0">
			   女:<input checked type="radio" name="sex" value="1"><br>
			   <!-- value="001" 在处理这种数据的时候,后台一般会有数据词典 -->
		爱好:  
			<!-- label 可以把内容和标签包括起来 -->
			<label>
				篮球 <input checked type="checkbox" name="like" value="001">  
			</label>
			
				足球 <input type="checkbox" name="like" value="002">
				乒乓球 <input checked type="checkbox" name="like" value="003"><br>
		经验:  
			<select name="exp">
				<option value="100">无</option>
				<option value="101" selected>1~3</option>
				<option value="102">3~5</option>
			</select><br>
		头像:  <input type="file" name="avatar"><br>
		个人介绍:  
		<textarea name="bak" cols="30" rows="5"></textarea><br>
		<input type="submit" value="提交">
	</form>
	<a href="http://www.baidu.com" >当前页面刷新</a>
	<a href="http://www.baidu.com" target="_parent">父类窗口刷新</a>
	<a href="http://www.baidu.com" target="_top">顶级父类窗口刷新</a>
</body>
</html>
```
## iframe 画中画 ##
```
	<iframe src="http://player.bilibili.com/player.html?	aid=31008479&cid=54146608&page=1" scrolling="no" border="0" 	frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>
	<iframe src="http://www.baidu.com" frameborder="0" scrolling="auto"></iframe>
```
- 原frame已废弃 iframe 既可以支持本地	HTML页面也支持 外网的链接;
###css的书写位置分为3种 css样式
+ 行内样式表 `<p style="color:blue;font-size: 30px;">我是一个p标签</p>`
+ 内嵌样式表 `<style> </style>`
+ 外部(链接)样式表 	`<link rel="stylesheet" href="style.css">`
+ 导入样式表     ` <style>  @import "style.css"; </style>`

##css样式层叠性和继承性 与css样式选择
> 如果出现了样式冲突 必然只能有一个样式生效
- 1. 如果写了相同选择器,希望某个选择器权重最高,只需额外添加class即可 谁权重高谁生效
- 2. 如果两个选择器是一样的 那么采用就近原则  权重一样 就近原则
+ 继承性 
- 几乎所有的字体属性都能被继承
特殊:

1.   a标签的颜色不能实现继承;
2.   h标签的大小不能实现继承;

## 常见选择器
+ 标签选择器  p
+ class选择器  .p1
+ id选择器   #p1
+ 交集选择器   .p1.danger
+ 并集选择器  .p1,.p2,.p3...
+ 后代选择器  .box .innerbox
+ 通用选择器  * 

## 简单选择器的优先级
+ 行内样式>id选择器>class选择器>标签选择器>通用选择器

## 复杂选择器优先级
+ 技巧: 
- 1. 如果写了相同选择器,希望某个选择器权重最高,只需额外添加class即可
- 2. 如果两个选择器是一样的 那么采用就近原则

+ 比较权重  权重可以叠加 
- 行内        1000
- id          100
- class       10 (一般选择器控制在3个以内)
- 标签        1
- 通用/继承   0 

+ 颜色
	- 预定义颜色： blue  yellow  pink  purple  red  等
	- 十六进制： 每两位表示一种颜色的深度  分别表示 red  green  blue; 比如： #ff00ff
	- rgb:   rgb(0,0,255) ==> 绿色 ； rgb和十六进制是可以互换的。
	- rgba:  rgba(0,0,255,0.5) ==> 跟rgb一样，a是透明度：0~1； 0.5==> .5
	- hsla
	- H 色调 取值范围0~360，0/360表示红色、120表示绿色、240表示蓝色
    - S 饱和度 取值范围0%~100%
    - L 亮度 取值范围0%~100%
    - A 透明度 取值范围0~1
    - #000000 十六进制表示颜色 这种情况也可以表示透明度 后面再加两位十六进制的透明度表示就可以的;  例如#00000000 #000000ff;
    - 100% — FF,99% — FC,98% — FA,97% — F7,96% — F5,95% — F2,94% — F0,93% — ED,92% — EB,91% — E8,90% — E6,89% — E3,88% — E0,87% — DE,86% — DB,85% — D9,84% — D6,83% — D4,82% — D1,81% — CF,80% — CC,79% — C9,78% — C7,77% — C4,76% — C2,75% — BF,74% — BD,73% — BA,72% — B8,71% — B5,70% — B3,69% — B0,68% — AD,67% — AB,66% — A8,65% — A6,64% — A3,63% — A1,62% — 9E,61% — 9C,60% — 99,59% — 96,58% — 94,57% — 91,56% — 8F,55% — 8C,54% — 8A,53% — 87,52% — 85,51% — 82,50% — 80,49% — 7D,48% — 7A,47% — 78,46% — 75,45% — 73,44% — 70,43% — 6E,42% — 6B,41% — 69,40% — 66,39% — 63,38% — 61,37% — 5E,36% — 5C,35% — 59,34% — 57,33% — 54,32% — 52,31% — 4F,30% — 4D,29% — 4A,28% — 47,27% — 45,26% — 42,25% — 40,24% — 3D,23% — 3B,22% — 38,21% — 36,20% — 33,19% — 30,18% — 2E,17% — 2B,16% — 29,15% — 26,14% — 24,13% — 21,12% — 1F,11% — 1C,10% — 1A,9% — 17,8% — 14,7% — 12,6% — 0F,5% — 0D,4% — 0A,3% — 08,2% — 05,1% — 03,0% — 00
	- opacity 会影响子类元素		用于单个元素
	- rgba(),hsla() 不会影响自带元素		常用于遮罩层
	- transparent 不可调节透明度，始终完全透明  常用于制作三角形
		

#常用属性
- | width / height  | 宽高(块状单位有效) | px 百分比 em等 |
- | text-align | 文字对齐方式 | center left right  
- | text-index | 首行缩进 | px  em等 |
- | cololr | 字体颜色 | color |
+ opacity透明度0-1  opacity可以改变字体透明度
##font 缩写形式
+ font|字体缩写|font:italic     (font-style | 字体样式 | Italic 斜体 / normal 正常)
+                   bolder     (font-weight | 字体加粗 | 100-900.加粗700-900/ bolder lighter normal)
+                   20px/1.2   (font-size | 字体大小 | px  em等 
                                line-height | 行高 | 单位px/倍数 /百分比;-设置文字的行间距-单行文字垂直居中,行高=父类盒子高度) 
+                   'Arial','Microsoft YaHei'    (font-family | 字体 | 微软雅黑	Microsoft YaHei、黑体 SimHei、Arial等)

##background 缩写形式
+ background  | 简写（顺序不能错） | 
+ background: green          (background-color  | 背景图片颜色 | color )
+            url(1.jpg)     (background-image  | 背景图片 | url("1.png");)
+            no-repeat      (background-repeat  | 平铺方式 | repeat 、 no-repeat  、 repeat-x 、 repeat-y)
+ 			 center center  (background-position  | 图片位置 |20px 30px left、 right、 top、 bottom、 center 相对于父类盒子水平垂直高度百分比50%60%)
+			 fixed; 	    (background-attachment  | 背景滚动 | scroll默认滚动、(fixed 注意：基于body的定位))
## 渐变 ##
- 线性渐变（Linear Gradients）- 向下/向上/向左/向右/对角方向
- 径向渐变（Radial Gradients）- 由它们的中心定义
- background: linear-gradient(direction(to left bottom[225deg]), color-stop1 [10%], color-stop2 [20%], ...);
- background: radial-gradient(center[10% 20%], shape size, start-color, ..., last-color);
- background  url可以设置多个属性 可用于自适应布局;
- background: url() no-repeat left top,url() no-repeat right top;

- background-size  设置背景图片的尺寸   此属性需要写在background后面才可以生效;
-    注意：是需要根据高度还是宽度适配
-  width height 直接设置宽高 百分比
- cover会自动调整缩放比例，保证图片始终填充满背景区域，如有溢出部分则会被隐藏。
- 整个背景图片完整显示在背景区域.
- contain会自动调整缩放比例，保证图片始终完整显示在背景区域。

- background-origin  (原点，起点)设置背景定位的原点  不会裁剪图片;
- border-box以边框做为参考原点；
- padding-box以内边距做为参考原点；
- content-box以内容区做为参考点；

- background-clip 设置背景区域clip(裁切)  
- border-box裁切边框以内为背景区域；
- padding-box裁切内边距以内为背景区域；
- content-box裁切内容区做为背景区域；


### 标签的表现形式
+ 块状标签  独占一行，宽高有效。 比如： div   p  h1~h6  form  table   hr  br  ul>li   ol>li dl>dt/dd 
+ 行内块标签  可以同一行显示，宽高有效。  比如: input select  img   button 
+ 行内标签  可以同一行显示，但是宽高无效， margin-top/margin-bottom 无效。。  比如： a   span   strong  del ins  em  i  b  等字体标签

### 盒子模型
> CSS处理网页时，它认为每个元素都包含在一个不可见的盒子里。包含内容区域、 padding（内边距） 、 border（边框）、margin（盒子与盒子的距离）

+ padding
	- padding:10px 20px 30px 40px 这样会设置元素的上、右、下、左四个方向的内边距。
	- padding:10px 20px 30px; 分别指定上、左右、下四个方向的内边距
	- padding:10px 20px; 分别指定上下、左右四个方向的内边距
	- padding:10px;同时指定上左右下四个方向的内边距
	- 同时在css中还提供了padding-top、padding-left、padding-right、padding-bottom分别用来指定四个方向的内边距。
+ margin
	- 用法和padding类似，同样也提供了四个方向的margin-top/right/bottom/left。
	- margin: xxx auto;可以使元素居中。
	- 嵌套崩塌：两个盒子发生嵌套的时候，给子类设置maring会给父类造成一种崩塌现象，子类的margin-top没有效果，而直接作用到父类。
	- 解决方案：  1. 父类  overflow: hidden ; 2. 父类 设置极小的padding
	- 重叠： 如果垂直两个块状元素同时设置了margin-bottom和margin-top,那么这两个值将会发生重叠,不会累加，哪个值大用哪个。
	- margin-top/margin-bottom 对于行内元素无效。
+ margin
	- 用法和padding类似，同样也提供了四个方向的margin-top/right/bottom/left。
	- margin: xxx auto;可以使元素居中。
	- 嵌套崩塌：两个盒子发生嵌套的时候，给子类设置maring会给父类造成一种崩塌现象，子类的margin-top没有效果，而直接作用到父类。
	- 解决方案：  1. 父类  overflow: hidden ; 2. 父类 设置极小的padding
	- 重叠： 如果垂直两个块状元素同时设置了margin-bottom和margin-top,那么这两个值将会发生重叠,不会累加，哪个值大用哪个。
	- margin-top/margin-bottom 对于行内元素无效。
	
+ border
	- 可以在元素周围创建边框，边框是元素可见框的最外部。
	- border:1px solid red 分别指定了边框的宽度、颜色和样式,是一种缩写： border-widht:  border-style border-color
	- border-style: none (默认)  /  dashed(虚线) / dotted（点）  / solid(实线)  /  double(双实线)
	- 可以单独设置某一条边框： border-right: 20px solid blue;
	- table border-collapse: collapse 合并边框;
	- border-image 属性是一个简写属性;
	- •	border-image-source  图片
	- •	border-image-slice	图片边框向内偏移量
	- •	border-image-width	边框宽度
	- •	border-image-outset  边框图像区域超出边框的量
	- •	border-image-repeat   图像边框是否应平铺(repeated)、铺满(rounded)或拉伸(stretched)。
	-  -webkit-border-image: url(border.png) 30 round; 


## css3新的属性和模型 ##
- css3 选择器  
- div[attr[*^$!=mydemo]]
- 伪类选择器 
- :link :active :visited :hover;  新的伪类 E:first-child :last-child 
-  :nth-child(n) 第n个 :nth-last-child(n); n可以是odd even   n支持简单的表达式; 3n + 1 -n+5;  2n-1;  n是自然数 n等于0的时候无效 小于零无效 :first-of-type
- E:empty 没有任何子节点的元素 连文本节点都不能有的   E:target 结合锚点使用 处于锚点的元素会被选中                              

### 伪元素 ###
-  ::before ::after   .clear::after {content""; dispaly:block;clear:both;}
-  ::first-letter 支持float ::first-line不支持float
-  ::selection 改变选中文本的样式
### 阴影 ###
- text-shadow text-shadow: h-shadow v-s,hadow [blur] [color];  
- box-shadow  h-shadow v-shadow [blur] [spread] [color] [inset]默认outset;  h-shadow	水平阴影的位置v-shadow垂直阴影  blur可选。模糊距离 spread	可选。阴影的尺寸。

### 新的盒子模型选择方式 ###
- box-sizing 指定盒子模型 content-box 对象的实际宽度为width padding 和border之和
-   border-box 对象实际的宽度就是设置的宽度;即使定义有border和padding也不会改变对象的实际宽度，即 ( Element width = width )
## 水平垂直居中 ##
> .father { height:200px; position:relative;}
> .son { position:absolute; top:0; right:0; bottom:0; top:0; margin:auto;}
> 利用position拉伸效果  和强行设置宽高会让多余的空间被剩余 margin 自动分配剩余空间的特性 IE8+

## css3动画 ##
- 过渡(transition)
- transition: all 520s ease 1314s
- transition-property 规定应用过渡的 CSS 属性的名称。
- transition-duration 定义过渡效果花费的时间。默认是 0。
- transition-timing-function 规定过渡效果的时间曲线。默认是 "ease"。
- transition-timing-function: linear|ease|ease-in|ease-out|ease-in-out|cubic-bezier(n,n,n,n);
- transition-delay 规定过渡效果何时开始。默认是 0。
-	2D转换
-	1)	缩放 scale(x, y) 可以对元素进行水平和垂直方向的缩放，x、y的取值可为小数，不可为负值
-	2)	移动 translate(x, y) 可以改变元素的位置，x、y可为负值；
-	3)	旋转 rotate(deg) 可以对元素进行旋转，正值为顺时针，负值为逆时针；
-	4)  倾斜    skew(x-angle,y-angle)	定义沿着 X 和 Y 轴的 2D 倾斜转换。
- transform-origin:left top; 转换的原点

### css3 3d 动画 ###
- 透视（perspective）
- perspective有两种写法
- a) 作为一个属性，设置给父元素，作用于所有3D转换的子元素
- b) 作为transform属性的一个值，做用于元素自身
- transform-style : preserve-3d：保留3D空间    flat：所有子元素在 2D 平面呈现
- backface-visibility：visible/ hidden
- 设置元素背面是否可见

- 通过@keyframes指定动画序列；创建动画
- @keyframes mylala { from { opacity:0}, 10% {opacity:0.1} 50%{opacity:0.8} to {opacity:1} }
- animation: 1.动画名称  2.动画持续时间  3.动画贝塞尔曲线[也可以是steps()分为多少步完成]  4.[动画延迟] 
-  5.重复次数[infinite] 
-  6.动画是否重置后再开始播放 [alternate 从上一次停止的位置开始执行，倒着来;normal	动画第二次直接跳到0%的状态开- 始执行]  
-  7. animation-play-state播放状态[ running 播放 和paused 暂停]  
-  8.动画执行完毕后状态 forwards backwards both;
 关键属性字 1 Animation-name  2. Animation-duration   3. animation-timing-function  4. animation-delay  5. animation-iteration-count 6.animation-direction	 7.animation-play-state 8.animation-fill-mode;
- animation: mylala 520s steps(360) 1314s infinite;
- 	linear	匀速。
- 	ease		缓冲。
- 	ease-in	由慢到快。
- 	ease-out	由快到慢。
- 	ease-in-out	由慢到快再到慢。
### 动画事件监听 ###

- x.addEventListener("animationend" ,myStartfunction() {},flase); 
- •	animationstart - CSS 动画开始后触发
- • animationiteration - CSS 动画重复播放时触发
- •	animationend - CSS 动画完成后触发
- 过渡事件监听
- 过渡完成事件

- Webkit内核：obj.addEventListener('webkitTransitionEnd',function(){},false); ???
## 移动端 ##
```
 <meta http-equiv="X-UA-Compatible" content="IE=edge"> 
 <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1,user-scalable=no">
禁止用户缩放;
//页面初始化
		resetFontSize();
		//窗口大小变化时候执行	
		window.onresize = function(){
			resetFontSize();
		}
		// 如何获取浏览器宽度
		function resetFontSize(){
			var clientWidth = document.documentElement.clientWidth;
			//获取html对象
			document.documentElement.style.fontSize = clientWidth/10+'px';
		}	
```
- 适配移动端的方式
+ 响应式			@media [screen and] (max-width: 700px) {} 通过媒体控制;
+       <link rel="stylesheet" media="screen and (min-width: 900px)" href="widescreen-styles.css" />
+ 针对移动端适配  通过控制rem 以前通过屏幕像素比
## js的组成 ##

- ECMAscript js标准 js基础语法
- dom 通过js操作网页元素 网页中的任意标签被称为dom元素
- bom 通过api操作浏览器

## js书写形式 ##
- 行内js 直接写在元素标签内的js代码
- <input type="butt
- " onclick="javascript:alert('哈哈')>  可以理解内部直接写函数调用  fn()  点击的时候调用函数 
-  此时fn函数内部的this为window对象  需要获得input对象可以 fn(this) 内部用一个obj接收  function fn(obj){console.log(obj)  };
- 内部js 写在页面<script> 标签内的js代码;
- 外部js 外部引入的js代码文件;

## 用js输出内容 ##

- alert() 在页面弹出一个对话框,早期js调试用
- confirm() 在页面弹出一个对话框.常配合if判断使用. 
```
	if(confirm("你是中国人吗?")){
		alert("您好")
	}else{
		alert("对不起我不会英语")
	}
```

- prompt() 弹出对话框,用于接收用户输入信息
- console.log() 将信息显示在控制台,用于js调试
- docunment.write() 在页面输出消息 几乎用不到
- docunment.write不仅能输出信息还能输出标签
- 转义字符 \ ,  \”   转双引  , \’转单引  ,  \n转换行  ,  \r 转回车

## js命名规范 ##

- 可以用英文_$开头
- 不能用特殊符号或者特殊符号开头
- 不能用数字开头
- 不推荐使用中文命名
- 不推荐使用关键字和保留字命名
- js中严格区分大小写

## js关键字 ##

> break	do	instanceof	typeof
case	else	new	var
catch	finally	return	void
continue	for	switch	while
debugger*	function	this	with
default	if	throw	delete
in	try	 	abstract	enum	int	short
boolean	export	interface	static
byte	extends	long	super
char	final	native	synchronized
class	float	package	throws
const	goto	private	transient
debugger	implements	protected	volatile
double	import	public	 

## js数据类型 ##

### 简单数据类型 ###


- Number 数字类型 包括正数负数小数
- 字符串 String凡是用单引号或者双引号 引起的都是字符串.
- 布尔数据类型 Boolean 只有两个值 true和false 实际运算中true=1 , false=0 
- underfined 
- 变量未初始化 定义了变量,没有给变量赋值
- null 变量未引用 值为空 object

### 复杂数据类型 ###

- object 对象  对象的属性可以是函数, 
- 我们称这个函数为对象的方法,  调用函数我们就说调用对象的方法;
### 调用对象的两种方法 ###
`	
	var person = {
    firstName:"John",
    lastName:"Doe",
    [1]:50,
    "!":"blue"
	};

	person.lastName;
	非正常命名用person[1] 中括号, 需要字符串的命名要用字符串加中括号调用   person["!"]
`



- array 数字
- 使用 typeof 可以判断数据类型

## 数据类型转换 ##
### 显性转换 强制类型转换
> 将其他的数据类型转换为String  
> 方式一
- 调用被转换数据类型的toString()方法    a = a.toString(); 
- toString方法不会影响到原变量,他会将转换的结果返回;
- 但是注意:null和undefined这两个值没有toString方法,如果调用他们的方法会报错
> 方式二
- 调用String()函数,并将被转换的数据作为参数传递给函数; a = String(a);
- 使用String()函数做强制类型转换时,对于Number和Boolean实际上就是调用的toString()方法;
- 但是对于null和undefined,就不会调用toString方法,直接将null变成"null" undefined变成"undefined";
> 将其他的数据类型转换为Number
>使用Number函数

- 纯数字字符串,直接转换为数字, a = Number("1234"); 1234
- 字符串有非数字内容转换为NaN, a = Number("12a");   NaN
- 字符串是空串或者全是空格的字符串转换为0, a = Number("")/Number("  ");  0 
- 布尔值转数字 ture 1 false 0
- Null 转换为 0;                 null表示"没有对象"，即该处不应该有值
- undefined 转换为 NaN 			undefined表示"缺少值"，就是此处应该有一个值，但是还没有定义
> 使用parseInt 和 parseFloat 专门对付字符串 如果传入非字符串会转换为字符串再解析
> parseInt(null)  NaN
> 从左往右查找数字,parseInt("123.23px")   123;
> parseInt(13,14) 17; 以14进制解析13;     45       2~36进制都可以用;
> a = 17;   a.toString(13) 以13进制解析17  14; 

> 转换为Boolean值
> 使用Boolean函数;
> 0,NaN,""空串,null,undefined,false 为假
### 进制转换 ###
> a = "070"  parseInt(a,10);



## 隐形类型转换 ##
> 任何类型和字符串相加都会转换为字符串 可以拼串; 内部调用String()
> (值) + ""  "(值)"  (1 + 1)  (2)   (true) (true)  前面的为括号运算  
> 算数运算符,对非Number类型的值进行运算时,会将这些值转换为Number类型,任何值和NaN做运算都是NaN;
> !!为任意数据类型做两次非运算,即可将其转换为boolean值  同Boolean()   !!可以用来判断是否为NaN?????

> 与或先将其转换为布尔值运算,之后返回原值; 与都为真才是真 有一个真就是真; 
> a++ 返回原值 ++a返回新值; 

## 比较运算符 ##
> > <  >= <=    数字或者有一个为数字比较前转换为Number类型比较  
> 比较两个字符串数字一定要转型   + "20"  >  + "19" 
> 都是字符串比较会比较unicode编码 只比较第一位  一位一位比较的  
> 有布尔值也会转换为Number进行比较   
> null == 0  为false;  
## 相等运算符 ##
#相等运算符转换规则和比较运算符不同 #
> 会把null当做对象看,null == undefined  null == null;
> undefined 衍生自null 所以判断== 会返回true
> NaN 不等于任何值,包括他自己;


> == != === !==
## js算数运算符 ##
>    运算符不会改变值  需要赋值获取换回结果

### unicode编码使用 ###
> 编码为16进制   js里面"\u2620" " 网页里&#编码;  "  这里的编码需要十进制;
-  +加号 
> 2 =  1 + 1  
>   
> 11  = 1 + "1"
> 
> woai1 = "woai" + 1

> 11woai = 1 + 10 + "woai"

> woai110  = "woai" + 11 + 0

- -减号
> 9 = 10 - 1
> 
> NaN = 10 - "您好"
> 
> NaN = "我好" - "你好"
> 
> NaN not a number

- /除号
> 1 = 1 / 1
> 
> 2 = 4 / "2"
> 
> NaN = "您好" / 2
> 
> Infinity = 1 / 0
> 
> -Infinity = -1 / 0
> 
> 有括号的先算括号里面的()


算数运算符,对非Number类型的值进行运算时,会将这些值转换为Number类型,任何值和NaN做运算都是NaN;

## 自增自减 ##

>如果变量没有直接参与运行中，i++  和  ++i表示的含义是：在变量原来值的基础上加1。
>
i++   i先参与运算，再执行++

> ++i   ++执行，i再参与运算 

## 运算符优先级 ##
- .   []   new
- ()
- ++   --
- !  ~  +单目  -单目  typeof void  delete
- %  *   /
-   双目+  双目-  
-   <<  >>  >>>
-   <  <=  >  >=
-   ==  !==  ===
-   &   ^    |
-   &&
-   ||
-     ?:
-     = +=  -=  *=  /=  %=  <<=   >>=  >>>=   &=   ^=   |=
-     ,
-     
-   不用记分不清的时候直接用()就可以的 

## Date 和 Math 对象使用 ##

### Date的用法 ###

> Date() 返回当前时间日期
> 
> getDate() 返回一个月的某一天
> 
> getMonth() 返回月份 以数字形式存储 返回0~11

> getFullYear() 返回年
>
> getHours() 返回小时部分
>
>getMinutes() 返回分钟部分
>
>getSeconds()返回秒数
>
>getDay() 从 Date 对象返回月份 (0 ~ 11)。
> 

### Math对象 ###
> Math.ceil() 天花板函数 对数字进行向上舍入 Math.ceil(2.3) 3
> 
> Math.floor() 地板函数 
> 
> Math.max(x,y) 返回最大值
> 
> Math.min(x,y) 返回最小值
> 
> Math.random()伪随机 返回[0,1)直接的数值
> 
> 任意随机数
> 1~100
> 
> Math.floor(Math.random()*数量+min) 
> 
> 即Math.floor(Math.random()*100+1) 
> 
> Math.pow(x,y) 返回X值的y次方
> 
> Math.round(x) 	把数四舍五入为最接近的整数。
> 
>  本身会有错误2.49999999999999999999 >==== 3 
> 

## 逻辑运算符 ##
- 先将其转换为布尔值运算,之后返回原值;
-  && || !
-  参与逻辑运算的都是布尔值.true和false 
-  &&都真才真 遇到false就返回 没有遇到就返回最后一个值(表达式的值)
-  || 只要有一个为真就是真 遇到true就返回,没有遇到就返回最后一个值(表达式的值)
-  转化为布尔值false的有 : underfined null NaN "" 0 false
-  !!强制将其他类型值转换为布尔类型值
## js基本语法规则 ##
- 语句后面要用分号结束;
- js语法错误会引发后续代码终止,但不会影响其他js代码块;
- 书写格式要规范,= + / - 两边都应该有空格;


## js语句 ##
>  {
> 		
> }
>  大括号表示代码块  把这些代码看出一个整体,要执行都执行,要不执行都不执行;
>  if(条件表达式true){
>
>   条件为真的时候做的事情
>   
> }else if{
>
>   条件为假的时候做的事情
>   
> }else{
> }
> 该语句只有一个代码块被执行,一旦代码块执行,立刻结束
>
> 三元运算符
>
> a>3 ? alert("大于3") : alert("小于3")

>Switch语句后的变量必须和case后面的数据类型保持一致,适合比较少的种类判断;
>Switch语句判断条件为全等;
>switch(变量n){
>
>     case 10:
>            执行的代码;
>            break;
>     case 20:
>            执行的代码;
>            break;
>     default:
>            执行的代码;
>            break;     
>
>While循环
>
>while(条件表达式){
>
>             当条件表达式结果为true,会一直执行while循环体内的代码。
>             
>             当条件表达式的结果为false，while循环不再执行。
>             
>             }  

>for循环
>      
>      for(var i = 0; i <= 1; i ++){
>          循环体代码
>      }       
>               
>执行顺序: 
- 首先进行变量初始化,并进行条件判断
- 如果条件结果为true,那么执行循环体内的代码,然后执行 i++;
- 判断条件是否为true,继续执行循环体内的代码,否则跳出循环
>
>Break 语句
>
>在循环体内 代码遇到break,代码立马结束当前循环,当前循环指的是break所在的循环体
>
>Continue 语句
>
>Continue语句指的是跳出本次循环,该语句后面的代码不被执行

#parseInt 

> parseInt(demo, 基底进制) 砍断特点 "100px"输出100 123.abc 输出123
				101010 2 以目标进制为基底转换为10进制
> string(demo)

> demo.toString() undifined null不能用

> demo.toSting(8) 把10进制转换成8进制; 以10进制转换为目标进制;
> 
把2进制转换成16进制

````

<script>
  var num 10101010;
  var test parseInt(num,2);
  console.log(test.toString(16));
</script>

```

## 预编译 ##
-   在全局作用域中 变量声明是给Windows对象创建了一个属性  函数声明是给Windows对象创建了一个方法  
-   变量是Windows的属性,函数是Windows对象的方法;
- 创建AO对象
- 找形参和变量声明.将变量和形参名作为AO属性名,值为undefined
- 将实参值和形参统一
- 在函数体里面找函数声明,值赋予函数体;

## this ##
- this 解析器调用函数时 会向函数传递一个隐含的参数, this指向一个对象(函数执行的上下文对象), 谁调用函数this就指向 谁(调用的对象);
- 当以函数的形式调用时,this是window;
- 当以方法的形式调用时,谁调用方法,this就是谁;
- 当以构造函数的形式调用时,this就是新创建的那个对象;
## arguments ##
- arguments就是实参列表
- arguments.callee() 函数自调用;

## Array 数组对象方法 ##
- 改变原数组
> push() 向数组的末尾添加一个或更多元素，并返回新的长度。
> pop() 删除并返回数组的最后一个元素 剪切出来最后一位.
> unshift() 	向数组的开头添加一个或更多元素，并返回新的长度。
> shift() 	删除并返回数组的第一个元素
> reverse() 	颠倒数组中元素的顺序。
> splice() 	删除元素，并向数组添加新元素。 切片 splice(从第几位开始,截取多少长度,在切口处添加新的数据)
> sort() 用于对数组的元素进行排序。默认unicode编码排序 arr.sort(function(a,b) {return}) 
- 必须写俩形参;
- 看返回值 
+ 当返回值为负数时,那么前面的数放在前面
+ 为正数时,那么后面的数在前
+ 为0, 不动;
> 
- 不改变原数组
> concat() 连接两个或更多的数组,并返回结果  
> 将一个数组与另一个或多个数组或非数组元素合并 并返回合并后的数组 需要接收
> join() 把数组的所有元素放入一个字符串.元素通过制定的分隔符进行分隔.
> toString() 把数组的所有元素放入一个字符串,元素通过指定的分隔符,进行分隔.
> indexOf("lala"[,从第几位开始找默认0]) 方法返回在数组中可以找到一个给定元素的第一个索引,如果不存在,则返回-1;  
> !!!!!   indexOf("") 会返回0 !!!!!
> lastIndexOf() 倒着搜索;
> slice() 从当前数组中截取一个新的数组，不影响原来的数组，参数 start 从0开
始, end 从1开始 返回一个新的数组，包含从  start 到  end （不包括该元素）的
arrayObject 中的元素。
> array = [];清空数组; array.length = 0;
> 
## 字符串的对象方法 ##
> charAt() 获取相应位置字符
> 
> charCodeAt() 方法可返回指定位置的字符的  Unicode 编码。这个返回值是 0 -
65535 之间的整数。

> split() stringObject.split(separator,howmany) 第一个参数分隔符第二个分出来的个数 返回数组,里面是字符串形式.
> 如果把空字符串 ("") 用作 separator，那么 stringObject 中的每个字符之间都会被分割。
> 
> indexOf() 返回字符在字符串中的位置
> lastindexOf()
> 
> concat() 连接字符串
> 
> slice() 方法可提取字符串的某个部分，并以新的字符串返回被提取的部分。
> 
> substr() 用的非常多 substr(起始位置,[取的个数])


> toUpperCase() toLowerCase()	变为大小写 ,不影响原字符串
> 
> substring() 
> 
> String 对象的方法 slice()、substring() 和 substr() （不建议使用）都可返回字符串的指定部分。slice() 比 substring() 要灵活一些，因为它允许使用负数作为参数。slice() 与 substr() 有所不同，因为它用两个字符的位置来指定子串，而 substr() 则用字符位置和长度来指定子串。
## json对象 ##
- 是对象的字符串表示形式 本质上是一个字符串 "{"name":value}";
- 转换
- obj ===> json
- var json = JSON.stringify(obj);
- json ===> obj
- var obj = JSON.parse(json);
## dom 常用操作指令 ##

### dom节点获得 ###
- document.getElementById("demo")
- 最准确的 ， 需要获取的dom元素，必须有id，而且一个页面不能有重复的id
- document.getElementsByTagName("div");
- 效率低  没办法定位元素
- document.getElementsByClassName("a");
- 如果在移动使用，移动端浏览器完全支持。 目前先不考虑<ie8情况，之后学了jQuery或者html5（新的选择器）;

### 节点通过父子属性获得 ###
- parentNode. 获得父亲节点
- nextSibling：调用者是节点
- nextElementSibling：在火狐谷歌IE9都指的是下一个元素节点
- 兼容写法：nextEle =节点.nextElementSibling || 节点.nextSibling 
- previousSibling：调用者是节点
- previousElementSibling：在火狐谷歌IE9都指的是前一个元素节点
- firstChild：调用者是父节点。IE678中指第一个子元素节点（标签）。在火狐谷歌IE9+以后都指的是第一个节点（包括空文档和换行节点）。
- firstElementChild:在火狐谷歌IE9都指的第一个元素节点。
- lastChild:调用者是父节点。IE678中指最后一个子元素节点（标签）。在火狐谷歌IE9+以后都指的是最后一个节点（包括空文档和换行节点）。
- lastElementChild：在火狐谷歌IE9都指的最后一个元素节点。
- childNodes：它是标准属性，嫡出，它返回指定元素的子元素集合，包括HTML节点，所有属性，文本节点   （他还是W3C的亲儿子 ）
火狐 谷歌等高本版会把换行也看做是子节点
- children：非标准属性，庶出，它返回指定元素的子元素集合
## dom节点的属性 ##
- nodeType === 1 Element  元素节点 nodeName  元素名     nodeValue  null
- nodeTyoe === 2 Attr     属性节点 nodeName  属性名称   nodeValue  属性值
- nodeType === 3 Text     文本节点 nodeName  #text     nodeValue  节点内容
- nodeType === 8 Comment  注释节点 nodeName  #comment  nodeValue  注释文本
- nodeType === 9 Document 代表整个文档 		#document			 null
- 
## dom节点操作 ##
- 创建节点
- 使用方法是这样的document.createElement();
- 
- 插入节点（使用节点）
- 父节点.appendChild(); var child =  Node.appendChild(child) 方法将一个节点添加到指定父节点的子节点列表末尾。
- var child = node.appendChild(child);
- node 是要插入子节点的父节点.
- child 即是参数又是这个方法的返回值.
### js获取节点 ###   
- document.title 文档标题;
- document.head  文档的头标签;
- document.body 文档的dody标签;
- document.documentElement   获得html标签;
- 获取父节点和兄弟节点
- parentNode   方法
- previousSibling
- nextSibling
- 
- 父节点.insertBefore(要插入的节点，参考节点)；
- 如果参考节点为null，那么他将在节点最后插入一个节点。

- 获得父元素子节点
- var node = 父元素.getElementByTagName("li") 方法返回当前节点的指定标签名后代节点
- var node = 父元素.childNodes; 所以的子节点; 
- firstChild 第一个子节点 lastChild 最后一个子节点;
- firstElementChild
- var elment = 父元素.children; 所以的子元素;
- 

- 删除节点   
- 用法：父节点.removeChild（子节点）。节点自己删除自己：
- 不知道父级的情况下，可以这么写：node.parentNode.removeChild(node)

- 复制节点 
- oldNode.cloneNode（true）
- 想要复制的节点调用这个函数cloneNode()，得到一个新节点。 方法内部可以传参，如果是true，深层复制，如果是false，只复制节点本身。

- 节点.属性
- elment.属性名 = 新值 可以修改属性值 className src
- 获取：getAttribute(名称)  当没有属性值的时候返回null 值;有属性值的时候返回字符串"类名"  
-         element.className 当没有属性值返回""空字符串
- 设置：setAttribute(名称, 值)  dom方法 调用属性要用getAttribute;
- 删除：removeAttribute(名称)
- 父元素.firstChild.nodeValue 第一个文本节点的节点值为文本信息;

- 插入元素
- innerHTML(内部的html)可以读可以写      插入可执行的标签，标签和样式会被解析，常用于动态生成页面元素  后面只能加入字符串  
- innerText 插入文本内容，标签和样式会被当做文本内容处理。 没有标签
- 获得表单内容 inputElement.value;

- document有一个body属性  var body = document.body; 就可以获得body的引用;
- var html = document.documentElement;  获得html



## 事件 ##
- 给HTML元素分配事件
- 1 可以使用事件属性,   <button onclick="displayDate()"> Try it </button>
- 2 使用HTML DOM 来分配事件   <script> document.getElementById("my btn").onclick = function(){displayDate()};</script>;
- onclick	鼠标点击某个对象
- onmouseover ;事件在鼠标指针移动到指定的元素上时发生。
- onmouseenter 事件在鼠标指针移动到元素上时触发。只有当鼠标移出元素才能再次触发;
- 仅当鼠标指针位于对象边界之外且用户将鼠标指针移动到对象边界内时，才会触发事件。 如果鼠标指针当前位于对象的边界内，则要触发事件，用户必须将鼠标指针移动到对象的边界之外，然后返回到对象的边界内。
- onmouseout	鼠标从某元素移开  ;
- onmouseleave 事件在鼠标移除元素时触发。 为移出该元素前不会重复触发;
- onfocus 	元素获得焦点。
- onblur 事件会在对象失去焦点时发生。
- window.onload = function(){};  页面dom加载完成之后执行的js代码
- onscroll事件 当元素的滚动条滚动时触发的事件.
- element.onscroll = function(){};  需要注意的是,设置此事件的元素一定要有滚动条.

## 事件对象 `Event`
- <a href="http://www.runoob.com/jsref/dom-obj-event.html">http://www.runoob.com/jsref/dom-obj-event.html</a> 
- !!!
- <a href="http://www.w3school.com.cn/jsref/dom_obj_event.asp">http://www.w3school.com.cn/jsref/dom_obj_event.asp</a>
`Event` 对象代表事件的状态，比如事件在其中发生的元素、键盘按键的状态、鼠标的位置、鼠标按钮的状态

获得event对象兼容性写法 `event || window.event`

`event.target` 事件的目标	获得target兼容型写法  `event.target || event.srcElement`

`e.pageX/Y`		获取鼠标点击的相对于页面的位置
`e.clientX/Y`	获取鼠标点击的相对于可视区域的位置
`e.screenX/Y`	获取鼠标点击的相对于屏幕的位置

`event.type`	事件的类型

`event.button` 鼠标点击的按键(只认识三个键) 可在 `onmousedown` 事件中测试
+ === 0 您点击了鼠标左键
+ === 1 您点击了鼠标中键
+ === 2 您点击了鼠标右键

## 事件监听

`addEventListener` 是 W3C DOM 规范中提供的注册事件监听器的方法。IE < 11 不支持此方法
> 事件监听的方式   addEventListener()		事件去掉 on
> 语法： target.addEventListener(type,listener,useCapture]);
> target： 文档节点、document、window。
> type： 字符串，事件名称，不含“on”，比如 “click”、“mouseover”、“keydown” 等。
> listener：执行函数,匿名函数或者声明函数
> useCapture ：是否使用捕捉，一般用 false。 IE 10 以下不支持捕获型事件
> 作用: 它允许给一个事件注册多个 listener
> 控制触发阶段	(捕获阶段 目标执行阶段 冒泡阶段)
> removeEventListener(事件,声明函数名字,是否不捕获) 需一致

`attachEvent(event,listener)` 也是用来监听事件的，只能用于 IE 10 以下，IE 11 已经废弃此方法

它的优点包括：

1. 它允许给一个事件注册多个 listener。

2. 它提供了一种更精细的手段控制 listener 的触发阶段。（即可以选择捕获或者冒泡）。

3. 事件目标可以是一个文档上的元素 Element,Document和Window或者任何其他支持事件的对象 (比如 XMLHttpRequest)。

> 语法： `target.addEventListener(type,listener,useCapture]);`
> 
> target： 文档节点、document、window 或 XMLHttpRequest。
> 
> type： 字符串，事件名称，不含“on”，比如 “click”、“mouseover”、“keydown” 等。 
> 
> listener：执行
> 。
> 
> useCapture ：是否使用捕捉，一般用 false。  IE 10 以下不支持捕获型事件
>
> 事件三阶段： 捕获阶段，处于目标阶段，冒泡阶段

## 鼠标滚轮事件监听 ##
- 关键代码：if(window.addEventListener){
			window.addEventListener("DOMMouseScroll",this.scroll,false);  //火狐
		}
		window.onmousewheel = this.scroll;   //IE  除了火狐之外 ，这种方式都能处理
- ie支持window.attachEvent添加侦听事件，非ie用window.addEventListener添加侦听事件


## `removeEventListener` 移除绑定

1. 如果同一个监听事件分别为“事件捕获”和“事件冒泡”注册了一次，一共两次，这两次事件需要分别移除。两者不会互相干扰。

2. 解绑事件 必须是 外部声明函数;


## 定时器
- 定时调用;
- var timer = setInter
- val(函数,间隔时间毫秒); 返回值唯一个Number类型的数据;
- 这个数字用来作为定时器的唯一标识  1 
- clearInterval(timer);  可以接受任意值 ,是有效的就停,不是有效的什么也不做; 
- index = index % imgArr[index]   index %= imgArr[index]图片循环  
- 延时调用
- var timer = setTimeout(function(){},300);
- clearTimeout(timer);

## BOM

`ECMAScript` 是 `javascript` 的核心，但是如果要在 `web` 中使用 `javascript`，那么 `BOM` (浏览器对象模型)才是真正的核心。BOM提供了很多对象，用于访问浏览器的功能，这些功能与任何网页内容无关。

`BOM` 的核心对象是 `window` ，它表示浏览器的一个实例。在浏览器中， `window` 对象有双重角色，它既是通过 `javascript` 访问浏览器窗口的一个接口，又是 `ECMAScript` 规定的 `Global` 对象。所有全局作用域中声明的变量、函数都会变成 `window` 对象的属性和方法。

### 三大家族其一 `Offset` 家族


> 家族成员： 
> `offsetWidth` `offsetHeight` `offsetLeft` `offsetTop` `offsetParent`

#### `offsetWidth`  `offsetHeight`  （检测盒子自身宽高）

> 这两个属性，他们绑定在了所有的节点元素上。获取之后，只要调用这两个属性，我们就能够获取元素节点的宽和高。

>` offset宽/高  =  盒子自身的宽/高(width/height) + padding +border`

#### `offsetLeft`  和  `offsetTop`  （检测距离父盒子有定位的左/上面的距离）

> 如果父级都没有定位则以 `body` 为准, `offsetLeft` 从父亲的 `padding` 开始算,父亲的 `border` 不算。
> 在父盒子有定位的情况下，`offsetLeft == style.left`(去掉 px)

#### `offsetTop/Left` 和 `style.top/left` 的区别：

1. 最大区别在于 `offsetTop/Left` 可以返回没有定位盒子的距离左侧的位置。而 `style.top/left` 不可以

2. `offsetTop/Left` 返回的是整数，而 `style.top/left` 返回的是字符串，除了数字外还带有单位：`px`

3. `offsetTop/Left` 只读，而 `style.top/left` 可读写。（只读是获取值，可写是赋值）

4. `obj.style.xxx` 只能获取行内样式

#### `offsetParent`   （检测父系盒子中带有定位的父盒子节点）

> 1、返回改对象的父级 （带有定位）
> 
> 如果当前元素的父级元素没有进行 CSS 定位(absolute,relative,fixed) `offsetParent` 为 `body`
>	
> 2、如果当前元素的父级元素中有 CSS 定位 `offsetParent` 取最近的那个父级元素。

## 缓动动画

> leader = leader + (target - leader) / 10;
> 起点 = 起点 + (终点 - 起点) / 10;


小点的点击事件
```js
for(var i = 0; i < dotts.length; i ++){
	dotts[i].onclick = function(i){
			return function (){
				n = i;
				dotClick(n);
				move(ulEle,n);
			}
	}(i)
}
```
缓动函数
```js
function move(ele,num){
	clearInterval(timer);
	var target = -num * w;
	timer = setInterval(function (){
		var start = ele.offsetLeft;
		if(start === target){
			clearInterval(timer);
			return;
		}
		var step = (target - start) / 10;
		if(Math.abs(step) < 1){
			step = step > 0 ? 1 : -1;
		}
		ele.style.left = start + step + "px";
	},17)
}
```
-----------------------------


## `Scroll` 家族

> 家族成员: `scrollWidth` , `scrollHeight` , `scrollTop` , `scrollLeft`
> scroll方法 , obj.scroll([function(){}]); 可以添加函数  
> scroll事件   
> window.scroll(x,y)`是让window滚动条滚动到那个x,y坐标。//x是水平坐标，y是垂直坐标。

> window.scrollBy(-x,-y)`是让window滚动条相对滚动到某个坐标，- 10即相对向左/向上滚动10像素。

> window.scrollTo(x,y)`和`window.scroll(x,y)`一样。

#### `scrollWidth` 和 `scrollHeight`

> 检测盒子的宽高  内容高度 + padding。（调用者：节点元素。属性。）
> 盒子内容的宽高。（如果有内容超出了，显示内容的高度）

#### `scrollTop` , `scrollLeft`
 
> 被浏览器遮挡的头部和左边部分。
> 可以获取或设置一个元素的内容垂直滚动的像素数。
> ** 浏览器兼容问题： **
> 各浏览器下 scrollTop的差异 
IE6/7/8： 
对于没有 doctype 声明的页面里可以使用  document.body.scrollTop 来获取 scrollTop高度 ； 
对于有 doctype 声明的页面则可以使用 document.documentElement.scrollTop； 
Safari: 
safari 比较特别，有自己获取scrollTop的函数 ： window.pageYOffset ； 
Firefox: 
火狐等等相对标准些的浏览器就省心多了，直接用 document.documentElement.scrollTop ；

兼容写法：
`var scrollTop = document.documentElement.scrollTop || window.pageYOffset || document.body.scrollTop`

## `Client` 家族

> 家族成员 `clientWidth` `clientHeight` `clientTop` `clientLeft`

#### `clientWidth` `clientHeight`

> 检测盒子的宽高 clientHeight/W 盒子 自身宽高 + padding 内容溢出不算
> offsetHeight/W 盒子 自身宽高+ padding + border  
> scrollHeight/W 内容宽高 + padding
> 
> document.documentElement.clientWidth/clientHeight  表示获取 window 可视区域的内部大小 没有兼容问题
> 
> 浏览器可视区域的宽高		没有兼容问题
> window.innerWidth/innerHeight		IE <= 8 不支持			表示获取 window 可视区域的内部大小
> window.outerWidth/outerHeight		IE <= 8 不支持			表示整个浏览器窗体的大小



#### `clientTop` `clientLeft`		只读

> 表示内容区域的左上角相对于整个元素左上角的位置实际上就是 border 的宽度
> 内容区域 内容+padding		padding 之外就剩border
> 一个元素顶部和左侧边框(border)的宽度

### offset scroll client 图片详解 ###
![](https://i.imgur.com/Zy1OBNS.png)
![](https://i.imgur.com/Fi3qsGR.png)
![](https://i.imgur.com/j7pEmfV.png)
https://blog.csdn.net/k491022087/article/details/52629743

## 获取元素的样式

> 内嵌样式	  行内样式  	可以通过 `ele.style.styleName` 获取
> 
> 内联样式和外联样式可以通过以下两种方式获取
### js获取css样式 ###
1. window.getComputedStyle(element[, pseudoElt伪元素 不写的时候最好默认为null]).styleName	 返回的是css设置样式 不一定是最终的样式	返回的是一个字符串,window可省略
2. https://www.zhangxinxu.com/wordpress/2012/05/getcomputedstyle-js-getpropertyvalue-currentstyle/  详情
2. element.currentStyle.styleName 仅用于 IE    返回最终的样式
	+ 仅用于谷歌和火狐等标准浏览器
	+ `element` 用于获取计算样式的元素。
	+ `pseudoElt` 指定一个要匹配的伪元素的字符串。必须对普通元素省略（或`null`）,一般都写成 `null`.  如果要获取伪元素的样式,则写上要获取的伪类的名字,例如:
	+ ```html
	
		<style>
			h3::after {
        content: "hello world!";
			}
		</style>
		<h3>带有伪元素</h3>
		<script>
			var h3 = document.getElementsByTagName('h3'), 
			result = getComputedStyle(h3, '::after').content;
			console.log(result); 		// "hello world!"
		</script>
		
	```
2. `element.currentStyle.styleName` 仅用于 IE 

3. 兼容写法:

```js

/**
* 获取任意元素的css样式
**/
function getStyle(ele,styleName){
	if(ele.currentStyle){
		return ele.currentStyle[styleName];
	}else{
		return window.getComputedStyle(ele,null)[styleName];
	}
}

```

**取对象的属性  如果该属性是变量,那么需要用[]的形式获取**

```js

var abc = "name";
var user = {
	name:'张三',
	age:20
}
console.log(user[abc]);

```

## 事件委托

> 通过监听一个父元素，来给不同的子元素绑定事件，减少监听次数，从而提升速度。
> 由于事件的冒泡机制,可以使用事件委托的方式给元素添加事件,多用于ul监听事件更改li的情景 

```
 lis[0].parentNode.onclick = function (e){
 e = e || window.event;
 var t = e.target;			// e.target  事件的目标  在IE下有兼容问题  e.srcElement
 var t = e.target || e.srcElement;
 console.log(t);
 元素的 元素.tagName 的返回值都是大写
 if(t.tagName === "LI"){
 t.style.color = "red";
}
}
```
## 阻止冒泡

> `event.st
> stopPropagation();`		存在兼容问题	(面试题)
> IE <= 10 专用 `event.cancelBubble = true`
> 兼容写法                                                                                      
> `event.stopPropagation?event.stopPropagation():event.cancelBubble = true;`

## jquery选择器 ##

-  "#"id .class tagName  * 所有元素 name,name 并集选择 
-  空格   后代选择器 所有的后代
-   >     子代选择器 ;
-  "+"  紧邻选择器 紧挨着的下一个;
-  "~"  兄弟选择器 后面所有的兄弟元素;
-   :eq(index) 选择第一个匹配的元素;   $(".class:eq[0]");
-   :gt(index) 大于index的元素;
-   :lt(index) 小于index的元素;
-   :odd   所有序号为奇数的元素;
-   :even  所有序号为偶数的元素;
-   :first  选择匹配的第一个元素;
-   :last   选择匹配的最后一个元素;
-   属性选择 $("a[href[='baidu']]")  =选择等于的时候 != 选择不包含此元素的, ^='web' 选择开头为web的;
-   $='cn' 选择以cn结尾的元素; *='i'选择所有包含i的元素;  "[href][tittle]" 属性可以交集选择;
-   筛选选择  
-   $(“#j_wrap”).find(“li”).css(“color”, “red”);
-   find() 查找所有后代;
-   children() 查找亲儿子 [子代] ;
-   siblings() 除了自己以外的所有兄弟节点;
-   sibling() 查找子代兄弟 确定元素时不包含自己; 
-   parent() 查找父亲的 亲的;
-   eq()  查找指定元素的第几个;
-   $(selector).index()可以用来返回下标
-   .css()  
-   获取样式  设置单个属性样式
-   设置多个属性样式 参数为js
-   on对象或者对象形式;
-   .attr() 
-   获取属性
-   设置属性
-   removeAttr();
-   取值设置值
-   text()  html()  val()
-   addClass() removeClass() toggleClass() hasClass()
-   next() 下一个兄弟 nextAll() 后面的所有兄弟   nextUntil 后面所有的兄弟直到..
-   prev() 前面的兄弟 prevAll() 前面所有的兄弟   prevUntil 前面的兄弟直到..
-   parent()   parents() 所有的父节点  parentsUntil()

## jquery入口函数 ##
- $(function() {});  dom结构加载完成后进行加载 此时dom内容不一定加载完成;  window.onload = function(){};  页面所有元素加载完成后进行加载;
- $(document).ready(function() {});  
## jQuery动画 ##
- 隐藏显示动画
- $(xx).show(2000,function(){});  	slow：600ms、normal：400ms、fast：200ms
- hide();
- 滑入滑出动画
- $(xx).slideDown(speed,callback);
- $(xx).slideUp();
- $(xx).slideToggle(speed,callback);
- 淡入淡出动画
- $(xx).fadeIn(speed, callback);
- $(xx).fadeOut(1000);
- $(xx).fadeToggle('fast',function(){});
- 改变透明度到某个值
- 	$(xx).fadeTo(1000, .5); //  0全透，1全不透
### 自定义动画 ###
- $(selector).animate(styles,speed,easing,callback)
- easing jQuery只包含了两个缓动方法：s
- wing和linear。linear方法提供了一个稳定的动画，以使得动画的每个步骤都是相同的(例如，如果要让一个元素以逐渐变化的方式穿过屏幕，每一步的距离和前一步都是相同的)。swing要更加动态一些，随着动画的开始变得更加快一些，然后再慢下来。swing是一个常用设置，因此，如果没有指定任何缓动，jQuery会使用swing方法。

### 停止动画 ###
- stop()
- 作用：停止当前正在执行的动画
- 如果多个动画同时作用于一个单位上面，那么多个动画会进入排队。后一个动画的执行必须等前面的执行完毕
- .stop(stopAll,goToEnd);
- stopAll  是否全部停止，默认false 停止队列中所有的动画
- goToEnd  是否将停止的动画  停止在当前动画的最后一个状态

## jQuery创建元素 ##
- var $spanNode = $(“<span>我是一个span元素</span>”);
- var $bodynode = $("body").html("<li>li</li>")；  最常用
### 添加元素
- append(存在或者创建出来的元素),
- 如果是页面中存在的元素，那么调用append()后，会把这个元素放到相应的目标元素里面去；但是，原来的这个元素，就不存在了。
- 如果是给多个目标追加元素，那么方法的内部会复制多份这个元素，然后追加到多个目标里面去
- appendTo()
- 作用：把$(selector)追加到node中去
- $(selector).appendTo(node);
-  prepend()
- 作用：在元素的第一个子元素前面追加内容或节点
- $(selector).prepend(node);
- after()
- 作用：在被选元素之后，作为兄弟元素插入内容或节点
- $(selector).after(node);

- before()
- 作用：在被选元素之前，作为兄弟元素插入内容或节点
- $(selector).before(node);
### 清空元素 ###
- $(selector).empty();
- $(selector).html(“”);
- $(selector).remove();  //会把对象也干掉
### 复制元素 ###
- $(selector).clone();

##  操作form表单
- .prop()

### jquery高度宽度 ###
- 	height()    取值类型为num  可以直接参与运算
-   height(200)
- 	width()
-	width(100)
- offset() 
- 作用：获取或设置元素相对于文档的位置
- 之前的offsetLeft  找有定位的父类 相对于有定位的父类的距离
	$(selector).offset();
	$(selector).offset({left:100, top: 150});
- 注意点：设置offset后，如果元素没有定位(默认值：static)，则被修改为relative

- position() 
- 作用：获取相对于其最近的具有定位的父元素的位置。
	$(selector).position();
- 注意：只能获取，不能设置。
- scrollTop() 
- 作用：获取或者设置元素垂直方向滚动的位置
	$(selector).scrollTop();
		$(selector).scrollTop(100);

- scrollLeft() 
- 作用：获取或者设置元素水平方向滚动的位置
- $(selector).scrollLeft(100);

## jQuery事件绑定 ##
- click(handler处理函数) 单击事件
- blur(handler) 失去焦点事件
- mouseenter(handler) 鼠标进入事件
- mouseleave(handler) 鼠标离开事件
- dbclick(handler) 双击事件;
- change(handler)改变事件 如 文本框值改变 , 下来列表值改变等
- focus(handler) 获得焦点事件
- keydown(handler) 键盘按下事件

-bind方式 直接绑定unblind解绑 ,deledate 给匹配元素绑定undeledate解绑
- on方式 集合两个优点
- $(selector).on(event[,selector][,data],handler);
- off解绑on方式绑定的事件;
- $(selector).off();
- $(selector).off("click");
- $(selector).off("click","XX"); 解绑所有代理的click事件,元素本身的事件不会被解绑;
- $(selector).off("click","xx",fn);
### 事件对象 ###
- event.data 传递给事件处理程序额外的程序
- event.currentTarget 等同于 this 当前dom对象;
- event.pageX 鼠标相对于文档左部边缘的位置;
- event.target 触发事件源;
- event.stopPropagation() 阻止事件冒泡行为;
- event.preventDefault(); 阻止默认行为;
- event.type 事件类型 例 click
- event.which 鼠标的按键类型 鼠标左键 1 鼠标中键 2 鼠标右键 3    鼠标移动时为0不点击;
- event.keyCode 键盘按键代码
## 事件触发 ##
- $(selector).click(function(event,data){console.log(data)}
- $(selector).click(); //触发click事件
- $(selector).trigger("click"[,data]);  可以传入参数;
- $(selector).triggerHandler(“click”); 
- triggerHandler 不会引起事件 (比如表单提交)的默认行为  
- triggerHandler 创建的事件不会在dom树里冒泡如果目标元素不直接处理它们，则不会发生任何事情。
- 该方法的返回的是事件处理函数的返回值，而不是具有可链性的 jQuery 对象。此外，如果没有处理程序被触发，则这个方法返回 undefined。
### jquery 链式编程 隐式迭代 each方法 ###
- 链式编程原理 : return:this; 调用"任何" 一个方法 都是返回了对象本身
- 通常情况下，只有设置操作才能把链式编程延续下去。因为获取操作的时候，会返回获取到的相应的值，无法返回 this。
- 例如 : $(selector).html() 会返回html的内容 (selector).html(<p></p>) 可以继续链式编程
- 隐式迭代的意思是：在方法的内部会为匹配到的所有元素进行循环遍历，执行相应的方法；而不用我们再进行循环，简化我们的操作，方便我们调用。
如果获取的是多元素的值，大部分情况下返回的是第一个元素的值。
- each方法  会遍历jquery对象的集合 为每个匹配元素执行一个函数
- $(selector).each(function(index,element) {});
- element是一个js对象 , 需要转换成jquery对象   
### 多库共存 ###
- jQuery 的团队考虑到了这个问题，并实现了 noConflict() 方法。
- $.noConflict();让jQuery释放对$的控制权，让其他库能够使用$符号，达到多库共存的目的。此后，只能使用jQuery来调用jQuery提供的方法

### jquery插件 ###
-  第三方
- jQuery.color.js
- animate()自定义动画：不支持背景的动画效果
- 自己制作插件
- 如何创建jQuery插件：
- http://learn.jquery.com/plugins/basic-plugin-creation/

- 全局jQuery函数扩展方法
- 	$.pluginName = function() {};

- jQuery对象扩展方法   fn=prototype  
- 	$.fn. pluginName = function() {};
- 考虑 封装一个自己的scrller库
> jQuery插件
> 日历
> 轮播
> 灯箱
> goto
> 视差
> 瀑布流

> 任何一种jq插件的使用过程
> 1.	下载插件库
> 2.	在页面引入插件的css或者字体图片等（如果有的话）
> 3.	在页面引入jQuery.js
> 4.	在页面引入插件的js文件（core）
> 5.	在页面通过插件的api初始化插件 即可使用（通过查看相应的API）

## html5标签 ##
- video 标签  兼容写法;
```
 <video width="320" height="240" controls="controls" autoplay="autoplay" muted>
  <source src="movie.ogg" type="video/ogg">
  <source src="movie.mp4" type="video/mp4">
  Your browser does not support the video tag. //插入的内容供不支持video元素的浏览器显示的;
 </video>
``` 
- 
- 浏览器禁止autoplay行为 影响用户体验 不过可以静音播放 添加 muted 静音播放属性;
- html标签语义化: 根据内容的结构化,选择合适的标签(代码语义化)
-  便于开发者阅读和写出更优雅的同事让浏览器的爬虫和机器更好地解析;
-  为什么要语义化?
-  为了在没有css的情况下,页面也能呈现出很好的内容结构,代码结构: 为了裸奔时好看;
-  用户体验: 例如title.alt用于解释名词或者解释图片信息 label标签的活用;
-  有利于seo: 和搜索引擎建立良好沟通, 有助于爬虫住区更多的有效信息:爬虫依赖于标签来确定上下文和各个关键字的权重;
-  方便其他设备解析(如屏幕阅读器,盲人阅读器,移动设备)以意义的方式来渲染网页;
-  便于团队开发和维护,语义化更具可读性,是下一步网页的重要动向,遵循w3c标准的团队都遵循这个标准,可以减少差异化;
-  3. 写HTML代码是应注意什么?
-  尽可能少的使用无语义得标签div和span;
-  在语义不明显是.既可以用div或者p时 尽量用p.
-  因为p在默认情况有上下间距 , 对兼容特殊终端端有利;
-  不要使用纯样式标签,如b font u等 改用css设置
-  需要强调的文本可以包含在strong或者em标签中(浏览器预设样式,能用css指定就不用他们) 
-  strong默认样式是加粗(不要用b),em是斜体不要用(i);
-  使用表格时, 标题要用caption.表头用thead. 主题用tbody包围.尾部用tfoot包围. 
-  表头和一般单元格要区分开. 表头用th 单元格用td;
-  表单域要用fieldset标签包起来. 并用legend标签说明表单的用途;
-  每个input标签对应的说明文本都需要使用label标签.并且通过为input设置id属性'
-  在lable标签中设置for=someld 来让说明文本和对应的input关联起来

```
  <from action="" method"">
       <fieldset>
             <legend>登录表单></legend>
             <p><label for="name">帐号:</label><input type="text" id="name"/></p>
             <p><label for="pw">密码:</label><input type="password" id="pw"/> </p>
             <input type="submit" value="登录" class="subBtn"/>
   </fieldset>
  </form>
```
- 面试题: 怎么看待html的语义化?
- http://www.cnblogs.com/yeshenyang/p/html_HTML5.html
- 
- html语义化可以让页面的内容结构化，便于浏览器解析，便于搜索引擎解析，并提高代码的可维护度和可重用性
- 
- audio 音频标签用法类似video;

## input标签新的type ##
- email url 
- number min="" max="" step="" 是一个选择框
- range min max step 是一个横向的可以拉动的条
- color 可以选择颜色;
- date 可以选择日期 里面有date month week time选择小时分钟 datetime utc时间 datetime-local 本地时间;
- search 搜索域 好处 可以直接esc 清空输入内容  语义化更加好 例如bing搜索
- datalist 选择提示效果
- 
```
<input list="cars" />
<datalist id="cars">
	<option value="BMW">
	<option value="Ford">
	<option value="Volvo">
</datalist>
```
ie safari不支持
- 注意detalist需要用input list属性进行绑定;

## css hack ##
- 低版本浏览器使用新标签兼容办法;
- 可以在一些低版本的浏览器中支持新标签,原理是把新的标签转换为div
- 这个语法只有在ie才能识别 刚好实现了在ie中引入 转换的库 的需求
-  lte   就是Less than or equal to的简写，也就是小于或等于的意思。
-	lt ：就是Less than的简写，也就是小于的意思。
-	gte：就是Greater than or equal to的简写，也就是大于或等于的意思。
-	gt ：就是Greater than的简写，也就是大于的意思。
-	!： 就是不等于的意思，跟javascript里的不等于判断符相同
-	注意：在非IE浏览器中是看不到效果的 -->

-	!!!<!-- 一定要注释起来 -->
```
	<!-- [if lte IE 8]> 
		<script src="lib/html5shiv.min.js"></script> 
	<![endif] -->
	<style>
		*{
			margin: 0;
			padding: 0;
		}
		.box{
			width: 200px;
			height: 200px;
			background-color: pink;
		}
		</style>
```
- 也可以 <!-- 针对ie浏览器的特定版本 制定特定样式   -->
```
	<!-- [if lte IE 8]> 
		<link rel="stylesheet" href="ie8.css">
	<![endif] -->	
```	
# seo优化 #
- 百度清风算法 对于网站恶意堆叠关键词会 降级
- 网站描述 会在百度的搜索结果中显示
- <meta name="description" content="河南郑州不凡学院开设UI设计培训课程和web前端开发课程。北京一线讲师现场教学，学习就等于工作。做自己擅长的事，分享知识与快乐！">
- 关键词:百度搜索 哪些词容易被抓取  
- <meta name="keywords" content="不凡学院,郑州UI培训,河南郑州UI设计培训,河南郑州前端开发培训,郑州H5培训,郑州WEB前端培训,郑州HTML5前端培训,郑州软件培训">
- <title>[官网] 不凡学院_河南郑州UI设计培训_河南郑州前端开发培训_郑州软件开发</title>
1. 关键词 很重要 根据经验 title 目前应该比keywords 权重高
2. 注意清风算法
  a) 在标题<head>部分不能随意堆叠关键词
  b) img 不能
  c) 可以在页面的内容 适当部分体现关键词
  d) logo 一定要写关键词
3. 注意网站链接 外链内链
4. 优质内容 原创内容 体现关键词
5. 更新 经常更新
6. <img src="" alt="不凡学院,郑州UI培训,河南郑州UI设计培训,河南郑州前端开发培训,郑州H5培训,郑州WEB前端培训,郑州HTML5前端培训,郑州软件培训" title="鼠标放上出现">

## h5选择器 ##
var liEle = document.querySelector("ul li");  第一个
var lis = document.querySelectorAll("li")[2];  可以选择所有的


## h5类名 ##
- class类名获取新的办法classList();  ie 10+ 
- data-(my-name)="mm" 获取Node.dataset['myName']
- <li data-div="box">li_1</li>
- var dEle = document.querySelector(".box");
- dEle.classList.add("d2");
- dEle.classList.remove("d1");
- dEle.classList.contains(); 是否包含 返回boolean值
- console.log(this.dataset.div);

## Web字体  字体格式 自定义字体##
1. TureTpe(.ttf)格式
- .ttf字体是Windows和Mac的最常见的字体，是一种RAW格式，支持这种字体的浏览器有IE9+、Firefox3.5+、Chrome4+、Safari3+、Opera10+、iOS Mobile、Safari4.2+；
2. OpenType(.otf)格式
- .otf字体被认为是一种原始的字体格式，其内置在TureType的基础上，支持这种字体的浏览器有Firefox3.5+、Chrome4.0+、Safari3.1+、Opera10.0+、iOS Mobile、Safari4.2+；
3. Web Open Font Format(.woff)格式
- woff字体是Web字体中最佳格式，他是一个开放的TrueType/OpenType的压缩版本，同时也支持元数据包的分离，支持这种字体的浏览器有IE9+、Firefox3.5+、Chrome6+、Safari3.6+、Opera11.1+；
4. Embedded Open Type(.eot)格式
- .eot字体是IE专用字体，可以从TrueType创建此格式字体，支持这种字体的浏览器有IE4+；
5. SVG(.svg)格式
- .svg字体是基于SVG字体渲染的一种格式，支持这种字体的浏览器有Chrome4+、Safari3.1+、Opera10.0+、iOS Mobile Safari3.2+；
- 了解了上面的知识后，我们就需要为不同的浏览器准备不同格式的字体，通常我们会通过字体生成工具帮我们生成各种格式的字体，因此无需过于在意字体格式间的区别差异。
- @font-face 自定义字体 
```
	@font-face {
      font-family: 'mzd';
      src: url('font/mzdzt.ttf');
    }
```
## 本地发布移动端
+ 下载node.js https://nodejs.org/en/
+ cmd ==>  node -v 查看版本
+ 可以执行本地js代码 shift+右键=> 打开命令窗口
+ node main.js
+ node.js 安装完了之后 自带 npm(node package manager)
+ 通过npm 安装一个本地服务 执行命令:  npm install http-server -g
+ 在项目文件夹执行 http-server -o ; 发布项目
+ cmd 输入 ipconfig -all ; 查看无线网ip 比如,http://192.168.0.157:8080/
+ 可以通过手机查看,手机必须处在当前的wifi
+ https://cli.im/ 生成二维码查看


